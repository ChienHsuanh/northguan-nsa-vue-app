//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

// @ts-nocheck
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (NJsonSchema v (Newtonsoft.Json v)) (http://NSwag.org)
// </auto-generated>
//----------------------

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export interface IAccountClient {
    getAccountList(page?: number | undefined, size?: number | undefined, keyword?: string | undefined,  cancelToken?: CancelToken): Promise<UserResponse[]>;
    createAccount(request: CreateAccountRequest,  cancelToken?: CancelToken): Promise<FileResponse>;
    getAccountCount(keyword?: string | undefined,  cancelToken?: CancelToken): Promise<CountResponse>;
    updateAccount(id: string, request: UpdateAccountRequest,  cancelToken?: CancelToken): Promise<FileResponse>;
    deleteAccount(id: string,  cancelToken?: CancelToken): Promise<FileResponse>;
}

export class AccountClient implements IAccountClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "https://localhost:7289";

    }

    getAccountList(page?: number | undefined, size?: number | undefined, keyword?: string | undefined, cancelToken?: CancelToken): Promise<UserResponse[]> {
        let url_ = this.baseUrl + "/api/accounts?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new globalThis.Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (keyword === null)
            throw new globalThis.Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAccountList(_response);
        });
    }

    protected processGetAccountList(response: AxiosResponse): Promise<UserResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserResponse.fromJS(item, _mappings));
            }
            else {
                result200 = null as any;
            }
            return Promise.resolve<UserResponse[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserResponse[]>(null as any);
    }

    createAccount(request: CreateAccountRequest, cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/accounts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateAccount(_response);
        });
    }

    protected processCreateAccount(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getAccountCount(keyword?: string | undefined, cancelToken?: CancelToken): Promise<CountResponse> {
        let url_ = this.baseUrl + "/api/account-count?";
        if (keyword === null)
            throw new globalThis.Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAccountCount(_response);
        });
    }

    protected processGetAccountCount(response: AxiosResponse): Promise<CountResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CountResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<CountResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CountResponse>(null as any);
    }

    updateAccount(id: string, request: UpdateAccountRequest, cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/accounts/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateAccount(_response);
        });
    }

    protected processUpdateAccount(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    deleteAccount(id: string, cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/accounts/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAccount(_response);
        });
    }

    protected processDeleteAccount(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface IAuthClient {
    login(request: LoginRequest,  cancelToken?: CancelToken): Promise<LoginResponse>;
    getProfile( cancelToken?: CancelToken): Promise<ProfileResponse>;
    updateProfile(name?: string | null | undefined, phone?: string | null | undefined, employeeId?: string | null | undefined, password?: string | null | undefined, avatarFile?: FileParameter | null | undefined,  cancelToken?: CancelToken): Promise<FileResponse>;
}

export class AuthClient implements IAuthClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "https://localhost:7289";

    }

    login(request: LoginRequest, cancelToken?: CancelToken): Promise<LoginResponse> {
        let url_ = this.baseUrl + "/api/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: AxiosResponse): Promise<LoginResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LoginResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<LoginResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LoginResponse>(null as any);
    }

    getProfile( cancelToken?: CancelToken): Promise<ProfileResponse> {
        let url_ = this.baseUrl + "/api/profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProfile(_response);
        });
    }

    protected processGetProfile(response: AxiosResponse): Promise<ProfileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProfileResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<ProfileResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProfileResponse>(null as any);
    }

    updateProfile(name?: string | null | undefined, phone?: string | null | undefined, employeeId?: string | null | undefined, password?: string | null | undefined, avatarFile?: FileParameter | null | undefined, cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (phone !== null && phone !== undefined)
            content_.append("Phone", phone.toString());
        if (employeeId !== null && employeeId !== undefined)
            content_.append("EmployeeId", employeeId.toString());
        if (password !== null && password !== undefined)
            content_.append("Password", password.toString());
        if (avatarFile !== null && avatarFile !== undefined)
            content_.append("AvatarFile", avatarFile.data, avatarFile.fileName ? avatarFile.fileName : "AvatarFile");

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateProfile(_response);
        });
    }

    protected processUpdateProfile(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface IDeviceClient {
    getDevices(type?: string | undefined, keyword?: string | undefined, page?: number | undefined, size?: number | undefined,  cancelToken?: CancelToken): Promise<DeviceListResponse[]>;
    createDevice(request: CreateDeviceRequest,  cancelToken?: CancelToken): Promise<FileResponse>;
    getDeviceCount(type?: string | undefined, keyword?: string | undefined,  cancelToken?: CancelToken): Promise<CountResponse>;
    updateDevice(id: number, request: UpdateDeviceRequest,  cancelToken?: CancelToken): Promise<FileResponse>;
    deleteDevice(id: number, type?: string | undefined,  cancelToken?: CancelToken): Promise<FileResponse>;
    getDevicesStatus(page?: number | undefined, size?: number | undefined, keyword?: string | undefined,  cancelToken?: CancelToken): Promise<DeviceStatusResponse[]>;
    getDevicesStatusCount( cancelToken?: CancelToken): Promise<CountResponse>;
    getDeviceStatusLogs(page?: number | undefined, size?: number | undefined, keyword?: string | undefined,  cancelToken?: CancelToken): Promise<DeviceStatusLogResponse[]>;
    getDeviceStatusLogCount(keyword?: string | undefined,  cancelToken?: CancelToken): Promise<CountResponse>;
    getDeviceStream(deviceId: number, type?: string | undefined, channelid?: string | undefined,  cancelToken?: CancelToken): Promise<FileResponse>;
}

export class DeviceClient implements IDeviceClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "https://localhost:7289";

    }

    getDevices(type?: string | undefined, keyword?: string | undefined, page?: number | undefined, size?: number | undefined, cancelToken?: CancelToken): Promise<DeviceListResponse[]> {
        let url_ = this.baseUrl + "/api/devices?";
        if (type === null)
            throw new globalThis.Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (keyword === null)
            throw new globalThis.Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new globalThis.Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDevices(_response);
        });
    }

    protected processGetDevices(response: AxiosResponse): Promise<DeviceListResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeviceListResponse.fromJS(item, _mappings));
            }
            else {
                result200 = null as any;
            }
            return Promise.resolve<DeviceListResponse[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceListResponse[]>(null as any);
    }

    createDevice(request: CreateDeviceRequest, cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/devices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateDevice(_response);
        });
    }

    protected processCreateDevice(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getDeviceCount(type?: string | undefined, keyword?: string | undefined, cancelToken?: CancelToken): Promise<CountResponse> {
        let url_ = this.baseUrl + "/api/device-count?";
        if (type === null)
            throw new globalThis.Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (keyword === null)
            throw new globalThis.Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDeviceCount(_response);
        });
    }

    protected processGetDeviceCount(response: AxiosResponse): Promise<CountResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CountResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<CountResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CountResponse>(null as any);
    }

    updateDevice(id: number, request: UpdateDeviceRequest, cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/devices/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateDevice(_response);
        });
    }

    protected processUpdateDevice(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    deleteDevice(id: number, type?: string | undefined, cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/devices/{id}?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (type === null)
            throw new globalThis.Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteDevice(_response);
        });
    }

    protected processDeleteDevice(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getDevicesStatus(page?: number | undefined, size?: number | undefined, keyword?: string | undefined, cancelToken?: CancelToken): Promise<DeviceStatusResponse[]> {
        let url_ = this.baseUrl + "/api/devices-status?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new globalThis.Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (keyword === null)
            throw new globalThis.Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDevicesStatus(_response);
        });
    }

    protected processGetDevicesStatus(response: AxiosResponse): Promise<DeviceStatusResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeviceStatusResponse.fromJS(item, _mappings));
            }
            else {
                result200 = null as any;
            }
            return Promise.resolve<DeviceStatusResponse[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceStatusResponse[]>(null as any);
    }

    getDevicesStatusCount( cancelToken?: CancelToken): Promise<CountResponse> {
        let url_ = this.baseUrl + "/api/devices-status-count";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDevicesStatusCount(_response);
        });
    }

    protected processGetDevicesStatusCount(response: AxiosResponse): Promise<CountResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CountResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<CountResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CountResponse>(null as any);
    }

    getDeviceStatusLogs(page?: number | undefined, size?: number | undefined, keyword?: string | undefined, cancelToken?: CancelToken): Promise<DeviceStatusLogResponse[]> {
        let url_ = this.baseUrl + "/api/devices-status-logs?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new globalThis.Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (keyword === null)
            throw new globalThis.Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDeviceStatusLogs(_response);
        });
    }

    protected processGetDeviceStatusLogs(response: AxiosResponse): Promise<DeviceStatusLogResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeviceStatusLogResponse.fromJS(item, _mappings));
            }
            else {
                result200 = null as any;
            }
            return Promise.resolve<DeviceStatusLogResponse[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceStatusLogResponse[]>(null as any);
    }

    getDeviceStatusLogCount(keyword?: string | undefined, cancelToken?: CancelToken): Promise<CountResponse> {
        let url_ = this.baseUrl + "/api/devices-status-logs-count?";
        if (keyword === null)
            throw new globalThis.Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDeviceStatusLogCount(_response);
        });
    }

    protected processGetDeviceStatusLogCount(response: AxiosResponse): Promise<CountResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CountResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<CountResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CountResponse>(null as any);
    }

    getDeviceStream(deviceId: number, type?: string | undefined, channelid?: string | undefined, cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/devices/{deviceId}/stream?";
        if (deviceId === undefined || deviceId === null)
            throw new globalThis.Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        if (type === null)
            throw new globalThis.Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (channelid === null)
            throw new globalThis.Error("The parameter 'channelid' cannot be null.");
        else if (channelid !== undefined)
            url_ += "channelid=" + encodeURIComponent("" + channelid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDeviceStream(_response);
        });
    }

    protected processGetDeviceStream(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface IExternalAlertClient {
    report(dto: ExternalAlertDto,  cancelToken?: CancelToken): Promise<ExternalAlertResponse>;
}

export class ExternalAlertClient implements IExternalAlertClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "https://localhost:7289";

    }

    report(dto: ExternalAlertDto, cancelToken?: CancelToken): Promise<ExternalAlertResponse> {
        let url_ = this.baseUrl + "/api/external-alert/report";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReport(_response);
        });
    }

    protected processReport(response: AxiosResponse): Promise<ExternalAlertResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ExternalAlertResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<ExternalAlertResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExternalAlertResponse>(null as any);
    }
}

export interface IHealthClient {
    get( cancelToken?: CancelToken): Promise<FileResponse>;
    getDetailed( cancelToken?: CancelToken): Promise<FileResponse>;
    getDatabaseHealth( cancelToken?: CancelToken): Promise<FileResponse>;
    getReadiness( cancelToken?: CancelToken): Promise<FileResponse>;
    getLiveness( cancelToken?: CancelToken): Promise<FileResponse>;
}

export class HealthClient implements IHealthClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "https://localhost:7289";

    }

    get( cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Health";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getDetailed( cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Health/detailed";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDetailed(_response);
        });
    }

    protected processGetDetailed(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getDatabaseHealth( cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Health/database";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDatabaseHealth(_response);
        });
    }

    protected processGetDatabaseHealth(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getReadiness( cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Health/ready";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReadiness(_response);
        });
    }

    protected processGetReadiness(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getLiveness( cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Health/live";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLiveness(_response);
        });
    }

    protected processGetLiveness(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface IMapClient {
    getLandmarks( cancelToken?: CancelToken): Promise<LandmarksResponse>;
    getLandmarkParking(id: number,  cancelToken?: CancelToken): Promise<ParkingLandmarkResponse>;
    getLandmarkTraffic(id: number,  cancelToken?: CancelToken): Promise<TrafficLandmarkResponse>;
    getLandmarkCrowd(id: number,  cancelToken?: CancelToken): Promise<CrowdLandmarkResponse>;
    getLandmarkFence(id: number,  cancelToken?: CancelToken): Promise<FenceLandmarkResponse>;
    getLandmarkHighResolution(id: number,  cancelToken?: CancelToken): Promise<HighResolutionLandmarkResponse>;
}

export class MapClient implements IMapClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "https://localhost:7289";

    }

    getLandmarks( cancelToken?: CancelToken): Promise<LandmarksResponse> {
        let url_ = this.baseUrl + "/api/landmarks";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLandmarks(_response);
        });
    }

    protected processGetLandmarks(response: AxiosResponse): Promise<LandmarksResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LandmarksResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<LandmarksResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LandmarksResponse>(null as any);
    }

    getLandmarkParking(id: number, cancelToken?: CancelToken): Promise<ParkingLandmarkResponse> {
        let url_ = this.baseUrl + "/api/landmarks/{id}/parking";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLandmarkParking(_response);
        });
    }

    protected processGetLandmarkParking(response: AxiosResponse): Promise<ParkingLandmarkResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ParkingLandmarkResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<ParkingLandmarkResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ParkingLandmarkResponse>(null as any);
    }

    getLandmarkTraffic(id: number, cancelToken?: CancelToken): Promise<TrafficLandmarkResponse> {
        let url_ = this.baseUrl + "/api/landmarks/{id}/traffic";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLandmarkTraffic(_response);
        });
    }

    protected processGetLandmarkTraffic(response: AxiosResponse): Promise<TrafficLandmarkResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TrafficLandmarkResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<TrafficLandmarkResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TrafficLandmarkResponse>(null as any);
    }

    getLandmarkCrowd(id: number, cancelToken?: CancelToken): Promise<CrowdLandmarkResponse> {
        let url_ = this.baseUrl + "/api/landmarks/{id}/crowd";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLandmarkCrowd(_response);
        });
    }

    protected processGetLandmarkCrowd(response: AxiosResponse): Promise<CrowdLandmarkResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CrowdLandmarkResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<CrowdLandmarkResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CrowdLandmarkResponse>(null as any);
    }

    getLandmarkFence(id: number, cancelToken?: CancelToken): Promise<FenceLandmarkResponse> {
        let url_ = this.baseUrl + "/api/landmarks/{id}/fence";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLandmarkFence(_response);
        });
    }

    protected processGetLandmarkFence(response: AxiosResponse): Promise<FenceLandmarkResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FenceLandmarkResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<FenceLandmarkResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FenceLandmarkResponse>(null as any);
    }

    getLandmarkHighResolution(id: number, cancelToken?: CancelToken): Promise<HighResolutionLandmarkResponse> {
        let url_ = this.baseUrl + "/api/landmarks/{id}/highResolution";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLandmarkHighResolution(_response);
        });
    }

    protected processGetLandmarkHighResolution(response: AxiosResponse): Promise<HighResolutionLandmarkResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = HighResolutionLandmarkResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<HighResolutionLandmarkResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<HighResolutionLandmarkResponse>(null as any);
    }
}

export interface IProxyClient {
    getCrowdImage(apiUrl?: string | undefined, channelid?: string | undefined, i?: string | null | undefined,  cancelToken?: CancelToken): Promise<FileResponse>;
    health( cancelToken?: CancelToken): Promise<FileResponse>;
}

export class ProxyClient implements IProxyClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "https://localhost:7289";

    }

    getCrowdImage(apiUrl?: string | undefined, channelid?: string | undefined, i?: string | null | undefined, cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Proxy/crowd-image?";
        if (apiUrl === null)
            throw new globalThis.Error("The parameter 'apiUrl' cannot be null.");
        else if (apiUrl !== undefined)
            url_ += "apiUrl=" + encodeURIComponent("" + apiUrl) + "&";
        if (channelid === null)
            throw new globalThis.Error("The parameter 'channelid' cannot be null.");
        else if (channelid !== undefined)
            url_ += "channelid=" + encodeURIComponent("" + channelid) + "&";
        if (i !== undefined && i !== null)
            url_ += "i=" + encodeURIComponent("" + i) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCrowdImage(_response);
        });
    }

    protected processGetCrowdImage(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    health( cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Proxy/health";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processHealth(_response);
        });
    }

    protected processHealth(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface IScheduledTaskClient {
    checkDevicesOnline( cancelToken?: CancelToken): Promise<DeviceOnlineCheckResponse>;
    syncCrowdData( cancelToken?: CancelToken): Promise<CrowdDataSyncResponse>;
    syncParkingData( cancelToken?: CancelToken): Promise<ParkingDataSyncResponse>;
    syncTrafficData( cancelToken?: CancelToken): Promise<TrafficDataSyncResponse>;
    backupDatabase( cancelToken?: CancelToken): Promise<DatabaseBackupResponse>;
    backupLogs( cancelToken?: CancelToken): Promise<LogBackupResponse>;
    cleanupAuditLogs( cancelToken?: CancelToken): Promise<AuditLogCleanupResponse>;
    getSystemHealth( cancelToken?: CancelToken): Promise<SystemHealthResponse>;
}

export class ScheduledTaskClient implements IScheduledTaskClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "https://localhost:7289";

    }

    checkDevicesOnline( cancelToken?: CancelToken): Promise<DeviceOnlineCheckResponse> {
        let url_ = this.baseUrl + "/api/ScheduledTask/check-devices-online";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckDevicesOnline(_response);
        });
    }

    protected processCheckDevicesOnline(response: AxiosResponse): Promise<DeviceOnlineCheckResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DeviceOnlineCheckResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<DeviceOnlineCheckResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceOnlineCheckResponse>(null as any);
    }

    syncCrowdData( cancelToken?: CancelToken): Promise<CrowdDataSyncResponse> {
        let url_ = this.baseUrl + "/api/ScheduledTask/sync-crowd-data";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSyncCrowdData(_response);
        });
    }

    protected processSyncCrowdData(response: AxiosResponse): Promise<CrowdDataSyncResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CrowdDataSyncResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<CrowdDataSyncResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CrowdDataSyncResponse>(null as any);
    }

    syncParkingData( cancelToken?: CancelToken): Promise<ParkingDataSyncResponse> {
        let url_ = this.baseUrl + "/api/ScheduledTask/sync-parking-data";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSyncParkingData(_response);
        });
    }

    protected processSyncParkingData(response: AxiosResponse): Promise<ParkingDataSyncResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ParkingDataSyncResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<ParkingDataSyncResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ParkingDataSyncResponse>(null as any);
    }

    syncTrafficData( cancelToken?: CancelToken): Promise<TrafficDataSyncResponse> {
        let url_ = this.baseUrl + "/api/ScheduledTask/sync-traffic-data";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSyncTrafficData(_response);
        });
    }

    protected processSyncTrafficData(response: AxiosResponse): Promise<TrafficDataSyncResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TrafficDataSyncResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<TrafficDataSyncResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TrafficDataSyncResponse>(null as any);
    }

    backupDatabase( cancelToken?: CancelToken): Promise<DatabaseBackupResponse> {
        let url_ = this.baseUrl + "/api/ScheduledTask/backup-database";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBackupDatabase(_response);
        });
    }

    protected processBackupDatabase(response: AxiosResponse): Promise<DatabaseBackupResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DatabaseBackupResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<DatabaseBackupResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DatabaseBackupResponse>(null as any);
    }

    backupLogs( cancelToken?: CancelToken): Promise<LogBackupResponse> {
        let url_ = this.baseUrl + "/api/ScheduledTask/backup-logs";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBackupLogs(_response);
        });
    }

    protected processBackupLogs(response: AxiosResponse): Promise<LogBackupResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LogBackupResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<LogBackupResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LogBackupResponse>(null as any);
    }

    cleanupAuditLogs( cancelToken?: CancelToken): Promise<AuditLogCleanupResponse> {
        let url_ = this.baseUrl + "/api/ScheduledTask/cleanup-audit-logs";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCleanupAuditLogs(_response);
        });
    }

    protected processCleanupAuditLogs(response: AxiosResponse): Promise<AuditLogCleanupResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuditLogCleanupResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<AuditLogCleanupResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuditLogCleanupResponse>(null as any);
    }

    getSystemHealth( cancelToken?: CancelToken): Promise<SystemHealthResponse> {
        let url_ = this.baseUrl + "/api/ScheduledTask/health";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSystemHealth(_response);
        });
    }

    protected processGetSystemHealth(response: AxiosResponse): Promise<SystemHealthResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SystemHealthResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<SystemHealthResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SystemHealthResponse>(null as any);
    }
}

export interface IStationClient {
    getStations(page?: number | undefined, size?: number | undefined, keyword?: string | undefined,  cancelToken?: CancelToken): Promise<StationResponse[]>;
    createStation(request: CreateStationRequest,  cancelToken?: CancelToken): Promise<FileResponse>;
    getStationCount(keyword?: string | undefined,  cancelToken?: CancelToken): Promise<CountResponse>;
    getStationDetail(id: number,  cancelToken?: CancelToken): Promise<StationResponse>;
    updateStation(id: number, request: UpdateStationRequest,  cancelToken?: CancelToken): Promise<FileResponse>;
    deleteStation(id: number,  cancelToken?: CancelToken): Promise<FileResponse>;
}

export class StationClient implements IStationClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "https://localhost:7289";

    }

    getStations(page?: number | undefined, size?: number | undefined, keyword?: string | undefined, cancelToken?: CancelToken): Promise<StationResponse[]> {
        let url_ = this.baseUrl + "/api/stations?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new globalThis.Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (keyword === null)
            throw new globalThis.Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStations(_response);
        });
    }

    protected processGetStations(response: AxiosResponse): Promise<StationResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StationResponse.fromJS(item, _mappings));
            }
            else {
                result200 = null as any;
            }
            return Promise.resolve<StationResponse[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StationResponse[]>(null as any);
    }

    createStation(request: CreateStationRequest, cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/stations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateStation(_response);
        });
    }

    protected processCreateStation(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getStationCount(keyword?: string | undefined, cancelToken?: CancelToken): Promise<CountResponse> {
        let url_ = this.baseUrl + "/api/station-count?";
        if (keyword === null)
            throw new globalThis.Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStationCount(_response);
        });
    }

    protected processGetStationCount(response: AxiosResponse): Promise<CountResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CountResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<CountResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CountResponse>(null as any);
    }

    getStationDetail(id: number, cancelToken?: CancelToken): Promise<StationResponse> {
        let url_ = this.baseUrl + "/api/stations/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStationDetail(_response);
        });
    }

    protected processGetStationDetail(response: AxiosResponse): Promise<StationResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StationResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<StationResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StationResponse>(null as any);
    }

    updateStation(id: number, request: UpdateStationRequest, cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/stations/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateStation(_response);
        });
    }

    protected processUpdateStation(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    deleteStation(id: number, cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/stations/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteStation(_response);
        });
    }

    protected processDeleteStation(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface ISystemSettingClient {
    getSystemSetting( cancelToken?: CancelToken): Promise<SystemSettingResponse>;
    updateSystemSetting(request: UpdateSystemSettingRequest,  cancelToken?: CancelToken): Promise<FileResponse>;
}

export class SystemSettingClient implements ISystemSettingClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "https://localhost:7289";

    }

    getSystemSetting( cancelToken?: CancelToken): Promise<SystemSettingResponse> {
        let url_ = this.baseUrl + "/api/systemSetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSystemSetting(_response);
        });
    }

    protected processGetSystemSetting(response: AxiosResponse): Promise<SystemSettingResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SystemSettingResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<SystemSettingResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SystemSettingResponse>(null as any);
    }

    updateSystemSetting(request: UpdateSystemSettingRequest, cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/systemSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateSystemSetting(_response);
        });
    }

    protected processUpdateSystemSetting(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface IThirdPartyApiClient {
    createFenceRecord(request: CreateFenceRecordRequest,  cancelToken?: CancelToken): Promise<CreateFenceRecordResponse>;
    updateFenceHeartbeat(request: UpdateFenceHeartbeatRequest,  cancelToken?: CancelToken): Promise<UpdateFenceHeartbeatResponse>;
    createCrowdRecord(request: CreateCrowdRecordRequest,  cancelToken?: CancelToken): Promise<CreateCrowdRecordResponse>;
    createApParkingRecord(request: CreateParkingRecordRequest,  cancelToken?: CancelToken): Promise<CreateParkingRecordResponse>;
    getStationList( cancelToken?: CancelToken): Promise<ThirdPartyStationInfo[]>;
    getFenceDeviceList( cancelToken?: CancelToken): Promise<ThirdPartyFenceDeviceInfo[]>;
    getCrowdDeviceList( cancelToken?: CancelToken): Promise<ThirdPartyCrowdDeviceInfo[]>;
    getParkingDeviceList( cancelToken?: CancelToken): Promise<ThirdPartyParkingDeviceInfo[]>;
    getTrafficDeviceList( cancelToken?: CancelToken): Promise<ThirdPartyTrafficDeviceInfo[]>;
    zeroTouchFileMaker( cancelToken?: CancelToken): Promise<FileResponse>;
    getFenceDeviceConfigs( cancelToken?: CancelToken): Promise<FenceDeviceConfigDto[]>;
    updateFenceZones(request: UpdateFenceZonesRequest,  cancelToken?: CancelToken): Promise<UpdateFenceZonesResponse>;
}

export class ThirdPartyApiClient implements IThirdPartyApiClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "https://localhost:7289";

    }

    createFenceRecord(request: CreateFenceRecordRequest, cancelToken?: CancelToken): Promise<CreateFenceRecordResponse> {
        let url_ = this.baseUrl + "/api/geofence/fence";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateFenceRecord(_response);
        });
    }

    protected processCreateFenceRecord(response: AxiosResponse): Promise<CreateFenceRecordResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateFenceRecordResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<CreateFenceRecordResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateFenceRecordResponse>(null as any);
    }

    updateFenceHeartbeat(request: UpdateFenceHeartbeatRequest, cancelToken?: CancelToken): Promise<UpdateFenceHeartbeatResponse> {
        let url_ = this.baseUrl + "/api/geofence/heartbeat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateFenceHeartbeat(_response);
        });
    }

    protected processUpdateFenceHeartbeat(response: AxiosResponse): Promise<UpdateFenceHeartbeatResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UpdateFenceHeartbeatResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<UpdateFenceHeartbeatResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateFenceHeartbeatResponse>(null as any);
    }

    createCrowdRecord(request: CreateCrowdRecordRequest, cancelToken?: CancelToken): Promise<CreateCrowdRecordResponse> {
        let url_ = this.baseUrl + "/api/pedestrian/count";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateCrowdRecord(_response);
        });
    }

    protected processCreateCrowdRecord(response: AxiosResponse): Promise<CreateCrowdRecordResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateCrowdRecordResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<CreateCrowdRecordResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateCrowdRecordResponse>(null as any);
    }

    createApParkingRecord(request: CreateParkingRecordRequest, cancelToken?: CancelToken): Promise<CreateParkingRecordResponse> {
        let url_ = this.baseUrl + "/api/parking/altobParking";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateApParkingRecord(_response);
        });
    }

    protected processCreateApParkingRecord(response: AxiosResponse): Promise<CreateParkingRecordResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateParkingRecordResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<CreateParkingRecordResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateParkingRecordResponse>(null as any);
    }

    getStationList( cancelToken?: CancelToken): Promise<ThirdPartyStationInfo[]> {
        let url_ = this.baseUrl + "/api/station/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStationList(_response);
        });
    }

    protected processGetStationList(response: AxiosResponse): Promise<ThirdPartyStationInfo[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ThirdPartyStationInfo.fromJS(item, _mappings));
            }
            else {
                result200 = null as any;
            }
            return Promise.resolve<ThirdPartyStationInfo[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ThirdPartyStationInfo[]>(null as any);
    }

    getFenceDeviceList( cancelToken?: CancelToken): Promise<ThirdPartyFenceDeviceInfo[]> {
        let url_ = this.baseUrl + "/api/pedestrian/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetFenceDeviceList(_response);
        });
    }

    protected processGetFenceDeviceList(response: AxiosResponse): Promise<ThirdPartyFenceDeviceInfo[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ThirdPartyFenceDeviceInfo.fromJS(item, _mappings));
            }
            else {
                result200 = null as any;
            }
            return Promise.resolve<ThirdPartyFenceDeviceInfo[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ThirdPartyFenceDeviceInfo[]>(null as any);
    }

    getCrowdDeviceList( cancelToken?: CancelToken): Promise<ThirdPartyCrowdDeviceInfo[]> {
        let url_ = this.baseUrl + "/api/pedestrian/op_list";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCrowdDeviceList(_response);
        });
    }

    protected processGetCrowdDeviceList(response: AxiosResponse): Promise<ThirdPartyCrowdDeviceInfo[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ThirdPartyCrowdDeviceInfo.fromJS(item, _mappings));
            }
            else {
                result200 = null as any;
            }
            return Promise.resolve<ThirdPartyCrowdDeviceInfo[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ThirdPartyCrowdDeviceInfo[]>(null as any);
    }

    getParkingDeviceList( cancelToken?: CancelToken): Promise<ThirdPartyParkingDeviceInfo[]> {
        let url_ = this.baseUrl + "/api/parking/op_list";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetParkingDeviceList(_response);
        });
    }

    protected processGetParkingDeviceList(response: AxiosResponse): Promise<ThirdPartyParkingDeviceInfo[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ThirdPartyParkingDeviceInfo.fromJS(item, _mappings));
            }
            else {
                result200 = null as any;
            }
            return Promise.resolve<ThirdPartyParkingDeviceInfo[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ThirdPartyParkingDeviceInfo[]>(null as any);
    }

    getTrafficDeviceList( cancelToken?: CancelToken): Promise<ThirdPartyTrafficDeviceInfo[]> {
        let url_ = this.baseUrl + "/api/etag/op_list";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTrafficDeviceList(_response);
        });
    }

    protected processGetTrafficDeviceList(response: AxiosResponse): Promise<ThirdPartyTrafficDeviceInfo[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ThirdPartyTrafficDeviceInfo.fromJS(item, _mappings));
            }
            else {
                result200 = null as any;
            }
            return Promise.resolve<ThirdPartyTrafficDeviceInfo[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ThirdPartyTrafficDeviceInfo[]>(null as any);
    }

    zeroTouchFileMaker( cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/zero_touch/make_excel";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processZeroTouchFileMaker(_response);
        });
    }

    protected processZeroTouchFileMaker(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getFenceDeviceConfigs( cancelToken?: CancelToken): Promise<FenceDeviceConfigDto[]> {
        let url_ = this.baseUrl + "/api/geofence/config";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetFenceDeviceConfigs(_response);
        });
    }

    protected processGetFenceDeviceConfigs(response: AxiosResponse): Promise<FenceDeviceConfigDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FenceDeviceConfigDto.fromJS(item, _mappings));
            }
            else {
                result200 = null as any;
            }
            return Promise.resolve<FenceDeviceConfigDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FenceDeviceConfigDto[]>(null as any);
    }

    updateFenceZones(request: UpdateFenceZonesRequest, cancelToken?: CancelToken): Promise<UpdateFenceZonesResponse> {
        let url_ = this.baseUrl + "/api/geofence/zones";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateFenceZones(_response);
        });
    }

    protected processUpdateFenceZones(response: AxiosResponse): Promise<UpdateFenceZonesResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UpdateFenceZonesResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<UpdateFenceZonesResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiErrorResponse.fromJS(resultData500, _mappings);
            return throwException("\u7cfb\u7d71\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateFenceZonesResponse>(null as any);
    }
}

export interface ICrowdClient {
    getRecordsList(minPeopleCount?: number | null | undefined, maxPeopleCount?: number | null | undefined, minDensity?: number | null | undefined, maxDensity?: number | null | undefined, minArea?: number | null | undefined, maxArea?: number | null | undefined, page?: number | undefined, size?: number | undefined, keyword?: string | undefined, sortBy?: string | undefined, sortOrder?: string | undefined, startDate?: Date | null | undefined, endDate?: Date | null | undefined, stationIds?: number[] | null | undefined, deviceSerials?: string[] | null | undefined,  cancelToken?: CancelToken): Promise<ResultOfPagedResponseOfCrowdRecordListResponse>;
    getRecordsCount(keyword?: string | undefined, availableStationIds?: number[] | null | undefined,  cancelToken?: CancelToken): Promise<ResultOfInteger>;
    exportRecords(keyword?: string | undefined, stationIds?: number[] | null | undefined, startDate?: Date | null | undefined, endDate?: Date | null | undefined, format?: string | undefined,  cancelToken?: CancelToken): Promise<FileResponse>;
    getRecentCapacityHistory(stationID?: number | undefined, timeRange?: number | undefined,  cancelToken?: CancelToken): Promise<CrowdCapacityHistoryResponse>;
    getRecentCapacityRate(stationID?: number | undefined, timeRange?: number | undefined, limit?: number | undefined,  cancelToken?: CancelToken): Promise<CrowdCapacityRateResponse>;
}

export class CrowdClient implements ICrowdClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "https://localhost:7289";

    }

    getRecordsList(minPeopleCount?: number | null | undefined, maxPeopleCount?: number | null | undefined, minDensity?: number | null | undefined, maxDensity?: number | null | undefined, minArea?: number | null | undefined, maxArea?: number | null | undefined, page?: number | undefined, size?: number | undefined, keyword?: string | undefined, sortBy?: string | undefined, sortOrder?: string | undefined, startDate?: Date | null | undefined, endDate?: Date | null | undefined, stationIds?: number[] | null | undefined, deviceSerials?: string[] | null | undefined, cancelToken?: CancelToken): Promise<ResultOfPagedResponseOfCrowdRecordListResponse> {
        let url_ = this.baseUrl + "/api/crowd-records?";
        if (minPeopleCount !== undefined && minPeopleCount !== null)
            url_ += "MinPeopleCount=" + encodeURIComponent("" + minPeopleCount) + "&";
        if (maxPeopleCount !== undefined && maxPeopleCount !== null)
            url_ += "MaxPeopleCount=" + encodeURIComponent("" + maxPeopleCount) + "&";
        if (minDensity !== undefined && minDensity !== null)
            url_ += "MinDensity=" + encodeURIComponent("" + minDensity) + "&";
        if (maxDensity !== undefined && maxDensity !== null)
            url_ += "MaxDensity=" + encodeURIComponent("" + maxDensity) + "&";
        if (minArea !== undefined && minArea !== null)
            url_ += "MinArea=" + encodeURIComponent("" + minArea) + "&";
        if (maxArea !== undefined && maxArea !== null)
            url_ += "MaxArea=" + encodeURIComponent("" + maxArea) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new globalThis.Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (keyword === null)
            throw new globalThis.Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sortBy === null)
            throw new globalThis.Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortOrder === null)
            throw new globalThis.Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (stationIds !== undefined && stationIds !== null)
            stationIds && stationIds.forEach(item => { url_ += "StationIds=" + encodeURIComponent("" + item) + "&"; });
        if (deviceSerials !== undefined && deviceSerials !== null)
            deviceSerials && deviceSerials.forEach(item => { url_ += "DeviceSerials=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRecordsList(_response);
        });
    }

    protected processGetRecordsList(response: AxiosResponse): Promise<ResultOfPagedResponseOfCrowdRecordListResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultOfPagedResponseOfCrowdRecordListResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<ResultOfPagedResponseOfCrowdRecordListResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ResultOfPagedResponseOfCrowdRecordListResponse.fromJS(resultData400, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ResultOfPagedResponseOfCrowdRecordListResponse.fromJS(resultData500, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultOfPagedResponseOfCrowdRecordListResponse>(null as any);
    }

    getRecordsCount(keyword?: string | undefined, availableStationIds?: number[] | null | undefined, cancelToken?: CancelToken): Promise<ResultOfInteger> {
        let url_ = this.baseUrl + "/api/crowd-records-count?";
        if (keyword === null)
            throw new globalThis.Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        if (availableStationIds !== undefined && availableStationIds !== null)
            availableStationIds && availableStationIds.forEach(item => { url_ += "availableStationIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRecordsCount(_response);
        });
    }

    protected processGetRecordsCount(response: AxiosResponse): Promise<ResultOfInteger> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultOfInteger.fromJS(resultData200, _mappings);
            return Promise.resolve<ResultOfInteger>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ResultOfInteger.fromJS(resultData500, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultOfInteger>(null as any);
    }

    exportRecords(keyword?: string | undefined, stationIds?: number[] | null | undefined, startDate?: Date | null | undefined, endDate?: Date | null | undefined, format?: string | undefined, cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/crowd-records-export?";
        if (keyword === null)
            throw new globalThis.Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        if (stationIds !== undefined && stationIds !== null)
            stationIds && stationIds.forEach(item => { url_ += "stationIds=" + encodeURIComponent("" + item) + "&"; });
        if (startDate !== undefined && startDate !== null)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (format === null)
            throw new globalThis.Error("The parameter 'format' cannot be null.");
        else if (format !== undefined)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportRecords(_response);
        });
    }

    protected processExportRecords(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = Result.fromJS(resultData500, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getRecentCapacityHistory(stationID?: number | undefined, timeRange?: number | undefined, cancelToken?: CancelToken): Promise<CrowdCapacityHistoryResponse> {
        let url_ = this.baseUrl + "/api/overview/crowd/recent-capacity-history?";
        if (stationID === null)
            throw new globalThis.Error("The parameter 'stationID' cannot be null.");
        else if (stationID !== undefined)
            url_ += "stationID=" + encodeURIComponent("" + stationID) + "&";
        if (timeRange === null)
            throw new globalThis.Error("The parameter 'timeRange' cannot be null.");
        else if (timeRange !== undefined)
            url_ += "timeRange=" + encodeURIComponent("" + timeRange) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRecentCapacityHistory(_response);
        });
    }

    protected processGetRecentCapacityHistory(response: AxiosResponse): Promise<CrowdCapacityHistoryResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CrowdCapacityHistoryResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<CrowdCapacityHistoryResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CrowdCapacityHistoryResponse>(null as any);
    }

    getRecentCapacityRate(stationID?: number | undefined, timeRange?: number | undefined, limit?: number | undefined, cancelToken?: CancelToken): Promise<CrowdCapacityRateResponse> {
        let url_ = this.baseUrl + "/api/overview/crowd/recent-capacity-rate?";
        if (stationID === null)
            throw new globalThis.Error("The parameter 'stationID' cannot be null.");
        else if (stationID !== undefined)
            url_ += "stationID=" + encodeURIComponent("" + stationID) + "&";
        if (timeRange === null)
            throw new globalThis.Error("The parameter 'timeRange' cannot be null.");
        else if (timeRange !== undefined)
            url_ += "timeRange=" + encodeURIComponent("" + timeRange) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRecentCapacityRate(_response);
        });
    }

    protected processGetRecentCapacityRate(response: AxiosResponse): Promise<CrowdCapacityRateResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CrowdCapacityRateResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<CrowdCapacityRateResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CrowdCapacityRateResponse>(null as any);
    }
}

export interface IFenceClient {
    getRecordsList(eventTypes?: string[] | null | undefined, page?: number | undefined, size?: number | undefined, keyword?: string | undefined, sortBy?: string | undefined, sortOrder?: string | undefined, startDate?: Date | null | undefined, endDate?: Date | null | undefined, stationIds?: number[] | null | undefined, deviceSerials?: string[] | null | undefined,  cancelToken?: CancelToken): Promise<ResultOfPagedResponseOfFenceRecordListResponse>;
    getRecordsCount(keyword?: string | undefined, availableStationIds?: number[] | null | undefined,  cancelToken?: CancelToken): Promise<ResultOfInteger>;
    exportRecords(keyword?: string | undefined, stationIds?: number[] | null | undefined, startDate?: Date | null | undefined, endDate?: Date | null | undefined, format?: string | undefined,  cancelToken?: CancelToken): Promise<FileResponse>;
    getRecentRecordHistory(stationID?: number | undefined, timeRange?: number | undefined,  cancelToken?: CancelToken): Promise<FenceRecordHistoryResponse>;
    getRecentRecord(stationID?: number | undefined, timeRange?: number | undefined, limit?: number | undefined,  cancelToken?: CancelToken): Promise<FenceRecentRecordDetailResponse>;
    getLatestRecord(stationID?: number | undefined,  cancelToken?: CancelToken): Promise<FenceLatestRecordResponse>;
}

export class FenceClient implements IFenceClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "https://localhost:7289";

    }

    getRecordsList(eventTypes?: string[] | null | undefined, page?: number | undefined, size?: number | undefined, keyword?: string | undefined, sortBy?: string | undefined, sortOrder?: string | undefined, startDate?: Date | null | undefined, endDate?: Date | null | undefined, stationIds?: number[] | null | undefined, deviceSerials?: string[] | null | undefined, cancelToken?: CancelToken): Promise<ResultOfPagedResponseOfFenceRecordListResponse> {
        let url_ = this.baseUrl + "/api/fence-records?";
        if (eventTypes !== undefined && eventTypes !== null)
            eventTypes && eventTypes.forEach(item => { url_ += "EventTypes=" + encodeURIComponent("" + item) + "&"; });
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new globalThis.Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (keyword === null)
            throw new globalThis.Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sortBy === null)
            throw new globalThis.Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortOrder === null)
            throw new globalThis.Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (stationIds !== undefined && stationIds !== null)
            stationIds && stationIds.forEach(item => { url_ += "StationIds=" + encodeURIComponent("" + item) + "&"; });
        if (deviceSerials !== undefined && deviceSerials !== null)
            deviceSerials && deviceSerials.forEach(item => { url_ += "DeviceSerials=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRecordsList(_response);
        });
    }

    protected processGetRecordsList(response: AxiosResponse): Promise<ResultOfPagedResponseOfFenceRecordListResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultOfPagedResponseOfFenceRecordListResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<ResultOfPagedResponseOfFenceRecordListResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ResultOfPagedResponseOfFenceRecordListResponse.fromJS(resultData400, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ResultOfPagedResponseOfFenceRecordListResponse.fromJS(resultData403, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ResultOfPagedResponseOfFenceRecordListResponse.fromJS(resultData500, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultOfPagedResponseOfFenceRecordListResponse>(null as any);
    }

    getRecordsCount(keyword?: string | undefined, availableStationIds?: number[] | null | undefined, cancelToken?: CancelToken): Promise<ResultOfInteger> {
        let url_ = this.baseUrl + "/api/fence-records-count?";
        if (keyword === null)
            throw new globalThis.Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        if (availableStationIds !== undefined && availableStationIds !== null)
            availableStationIds && availableStationIds.forEach(item => { url_ += "availableStationIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRecordsCount(_response);
        });
    }

    protected processGetRecordsCount(response: AxiosResponse): Promise<ResultOfInteger> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultOfInteger.fromJS(resultData200, _mappings);
            return Promise.resolve<ResultOfInteger>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ResultOfInteger.fromJS(resultData500, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultOfInteger>(null as any);
    }

    exportRecords(keyword?: string | undefined, stationIds?: number[] | null | undefined, startDate?: Date | null | undefined, endDate?: Date | null | undefined, format?: string | undefined, cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/fence-records-export?";
        if (keyword === null)
            throw new globalThis.Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        if (stationIds !== undefined && stationIds !== null)
            stationIds && stationIds.forEach(item => { url_ += "stationIds=" + encodeURIComponent("" + item) + "&"; });
        if (startDate !== undefined && startDate !== null)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (format === null)
            throw new globalThis.Error("The parameter 'format' cannot be null.");
        else if (format !== undefined)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportRecords(_response);
        });
    }

    protected processExportRecords(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = Result.fromJS(resultData500, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getRecentRecordHistory(stationID?: number | undefined, timeRange?: number | undefined, cancelToken?: CancelToken): Promise<FenceRecordHistoryResponse> {
        let url_ = this.baseUrl + "/api/overview/fence/recent-record-history?";
        if (stationID === null)
            throw new globalThis.Error("The parameter 'stationID' cannot be null.");
        else if (stationID !== undefined)
            url_ += "stationID=" + encodeURIComponent("" + stationID) + "&";
        if (timeRange === null)
            throw new globalThis.Error("The parameter 'timeRange' cannot be null.");
        else if (timeRange !== undefined)
            url_ += "timeRange=" + encodeURIComponent("" + timeRange) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRecentRecordHistory(_response);
        });
    }

    protected processGetRecentRecordHistory(response: AxiosResponse): Promise<FenceRecordHistoryResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FenceRecordHistoryResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<FenceRecordHistoryResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FenceRecordHistoryResponse>(null as any);
    }

    getRecentRecord(stationID?: number | undefined, timeRange?: number | undefined, limit?: number | undefined, cancelToken?: CancelToken): Promise<FenceRecentRecordDetailResponse> {
        let url_ = this.baseUrl + "/api/overview/fence/recent-record?";
        if (stationID === null)
            throw new globalThis.Error("The parameter 'stationID' cannot be null.");
        else if (stationID !== undefined)
            url_ += "stationID=" + encodeURIComponent("" + stationID) + "&";
        if (timeRange === null)
            throw new globalThis.Error("The parameter 'timeRange' cannot be null.");
        else if (timeRange !== undefined)
            url_ += "timeRange=" + encodeURIComponent("" + timeRange) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRecentRecord(_response);
        });
    }

    protected processGetRecentRecord(response: AxiosResponse): Promise<FenceRecentRecordDetailResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FenceRecentRecordDetailResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<FenceRecentRecordDetailResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FenceRecentRecordDetailResponse>(null as any);
    }

    getLatestRecord(stationID?: number | undefined, cancelToken?: CancelToken): Promise<FenceLatestRecordResponse> {
        let url_ = this.baseUrl + "/api/overview/fence/latest-record?";
        if (stationID === null)
            throw new globalThis.Error("The parameter 'stationID' cannot be null.");
        else if (stationID !== undefined)
            url_ += "stationID=" + encodeURIComponent("" + stationID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLatestRecord(_response);
        });
    }

    protected processGetLatestRecord(response: AxiosResponse): Promise<FenceLatestRecordResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FenceLatestRecordResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<FenceLatestRecordResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FenceLatestRecordResponse>(null as any);
    }
}

export interface IParkingClient {
    getRecordsList(minTotalSpaces?: number | null | undefined, maxTotalSpaces?: number | null | undefined, minOccupancyRate?: number | null | undefined, maxOccupancyRate?: number | null | undefined, page?: number | undefined, size?: number | undefined, keyword?: string | undefined, sortBy?: string | undefined, sortOrder?: string | undefined, startDate?: Date | null | undefined, endDate?: Date | null | undefined, stationIds?: number[] | null | undefined, deviceSerials?: string[] | null | undefined,  cancelToken?: CancelToken): Promise<ResultOfPagedResponseOfParkingRecordListResponse>;
    getRecordsCount(keyword?: string | undefined, availableStationIds?: number[] | null | undefined,  cancelToken?: CancelToken): Promise<ResultOfInteger>;
    exportRecords(keyword?: string | undefined, stationIds?: number[] | null | undefined, startDate?: Date | null | undefined, endDate?: Date | null | undefined, format?: string | undefined,  cancelToken?: CancelToken): Promise<FileResponse>;
    getRecentConversionHistory(stationID?: number | undefined, timeRange?: number | undefined,  cancelToken?: CancelToken): Promise<ParkingConversionHistoryResponse>;
    getRecentParkingRate(stationID?: number | undefined, timeRange?: number | undefined, limit?: number | undefined,  cancelToken?: CancelToken): Promise<ParkingRateResponse>;
}

export class ParkingClient implements IParkingClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "https://localhost:7289";

    }

    getRecordsList(minTotalSpaces?: number | null | undefined, maxTotalSpaces?: number | null | undefined, minOccupancyRate?: number | null | undefined, maxOccupancyRate?: number | null | undefined, page?: number | undefined, size?: number | undefined, keyword?: string | undefined, sortBy?: string | undefined, sortOrder?: string | undefined, startDate?: Date | null | undefined, endDate?: Date | null | undefined, stationIds?: number[] | null | undefined, deviceSerials?: string[] | null | undefined, cancelToken?: CancelToken): Promise<ResultOfPagedResponseOfParkingRecordListResponse> {
        let url_ = this.baseUrl + "/api/parking-records?";
        if (minTotalSpaces !== undefined && minTotalSpaces !== null)
            url_ += "MinTotalSpaces=" + encodeURIComponent("" + minTotalSpaces) + "&";
        if (maxTotalSpaces !== undefined && maxTotalSpaces !== null)
            url_ += "MaxTotalSpaces=" + encodeURIComponent("" + maxTotalSpaces) + "&";
        if (minOccupancyRate !== undefined && minOccupancyRate !== null)
            url_ += "MinOccupancyRate=" + encodeURIComponent("" + minOccupancyRate) + "&";
        if (maxOccupancyRate !== undefined && maxOccupancyRate !== null)
            url_ += "MaxOccupancyRate=" + encodeURIComponent("" + maxOccupancyRate) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new globalThis.Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (keyword === null)
            throw new globalThis.Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sortBy === null)
            throw new globalThis.Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortOrder === null)
            throw new globalThis.Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (stationIds !== undefined && stationIds !== null)
            stationIds && stationIds.forEach(item => { url_ += "StationIds=" + encodeURIComponent("" + item) + "&"; });
        if (deviceSerials !== undefined && deviceSerials !== null)
            deviceSerials && deviceSerials.forEach(item => { url_ += "DeviceSerials=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRecordsList(_response);
        });
    }

    protected processGetRecordsList(response: AxiosResponse): Promise<ResultOfPagedResponseOfParkingRecordListResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultOfPagedResponseOfParkingRecordListResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<ResultOfPagedResponseOfParkingRecordListResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ResultOfPagedResponseOfParkingRecordListResponse.fromJS(resultData400, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ResultOfPagedResponseOfParkingRecordListResponse.fromJS(resultData403, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ResultOfPagedResponseOfParkingRecordListResponse.fromJS(resultData500, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultOfPagedResponseOfParkingRecordListResponse>(null as any);
    }

    getRecordsCount(keyword?: string | undefined, availableStationIds?: number[] | null | undefined, cancelToken?: CancelToken): Promise<ResultOfInteger> {
        let url_ = this.baseUrl + "/api/parking-records-count?";
        if (keyword === null)
            throw new globalThis.Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        if (availableStationIds !== undefined && availableStationIds !== null)
            availableStationIds && availableStationIds.forEach(item => { url_ += "availableStationIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRecordsCount(_response);
        });
    }

    protected processGetRecordsCount(response: AxiosResponse): Promise<ResultOfInteger> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultOfInteger.fromJS(resultData200, _mappings);
            return Promise.resolve<ResultOfInteger>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ResultOfInteger.fromJS(resultData500, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultOfInteger>(null as any);
    }

    exportRecords(keyword?: string | undefined, stationIds?: number[] | null | undefined, startDate?: Date | null | undefined, endDate?: Date | null | undefined, format?: string | undefined, cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/parking-records-export?";
        if (keyword === null)
            throw new globalThis.Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        if (stationIds !== undefined && stationIds !== null)
            stationIds && stationIds.forEach(item => { url_ += "stationIds=" + encodeURIComponent("" + item) + "&"; });
        if (startDate !== undefined && startDate !== null)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (format === null)
            throw new globalThis.Error("The parameter 'format' cannot be null.");
        else if (format !== undefined)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportRecords(_response);
        });
    }

    protected processExportRecords(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = Result.fromJS(resultData500, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getRecentConversionHistory(stationID?: number | undefined, timeRange?: number | undefined, cancelToken?: CancelToken): Promise<ParkingConversionHistoryResponse> {
        let url_ = this.baseUrl + "/api/overview/parking/recent-conversion-history?";
        if (stationID === null)
            throw new globalThis.Error("The parameter 'stationID' cannot be null.");
        else if (stationID !== undefined)
            url_ += "stationID=" + encodeURIComponent("" + stationID) + "&";
        if (timeRange === null)
            throw new globalThis.Error("The parameter 'timeRange' cannot be null.");
        else if (timeRange !== undefined)
            url_ += "timeRange=" + encodeURIComponent("" + timeRange) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRecentConversionHistory(_response);
        });
    }

    protected processGetRecentConversionHistory(response: AxiosResponse): Promise<ParkingConversionHistoryResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ParkingConversionHistoryResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<ParkingConversionHistoryResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ParkingConversionHistoryResponse>(null as any);
    }

    getRecentParkingRate(stationID?: number | undefined, timeRange?: number | undefined, limit?: number | undefined, cancelToken?: CancelToken): Promise<ParkingRateResponse> {
        let url_ = this.baseUrl + "/api/overview/parking/recent-parking-rate?";
        if (stationID === null)
            throw new globalThis.Error("The parameter 'stationID' cannot be null.");
        else if (stationID !== undefined)
            url_ += "stationID=" + encodeURIComponent("" + stationID) + "&";
        if (timeRange === null)
            throw new globalThis.Error("The parameter 'timeRange' cannot be null.");
        else if (timeRange !== undefined)
            url_ += "timeRange=" + encodeURIComponent("" + timeRange) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRecentParkingRate(_response);
        });
    }

    protected processGetRecentParkingRate(response: AxiosResponse): Promise<ParkingRateResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ParkingRateResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<ParkingRateResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ParkingRateResponse>(null as any);
    }
}

export interface ITrafficClient {
    getRecordsList(minVehicleCount?: number | null | undefined, maxVehicleCount?: number | null | undefined, minAverageSpeed?: number | null | undefined, maxAverageSpeed?: number | null | undefined, speedStatuses?: string[] | null | undefined, cities?: string[] | null | undefined, page?: number | undefined, size?: number | undefined, keyword?: string | undefined, sortBy?: string | undefined, sortOrder?: string | undefined, startDate?: Date | null | undefined, endDate?: Date | null | undefined, stationIds?: number[] | null | undefined, deviceSerials?: string[] | null | undefined,  cancelToken?: CancelToken): Promise<ResultOfPagedResponseOfTrafficRecordListResponse>;
    getRecordsCount(keyword?: string | undefined, availableStationIds?: number[] | null | undefined,  cancelToken?: CancelToken): Promise<ResultOfInteger>;
    exportRecords(keyword?: string | undefined, stationIds?: number[] | null | undefined, startDate?: Date | null | undefined, endDate?: Date | null | undefined, format?: string | undefined,  cancelToken?: CancelToken): Promise<FileResponse>;
    getRecentRoadConditionHistory(stationID?: number | undefined, timeRange?: number | undefined,  cancelToken?: CancelToken): Promise<TrafficRoadConditionHistoryResponse>;
    getRecentRoadCondition(stationID?: number | undefined, timeRange?: number | undefined, limit?: number | undefined,  cancelToken?: CancelToken): Promise<TrafficRoadConditionResponse>;
}

export class TrafficClient implements ITrafficClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "https://localhost:7289";

    }

    getRecordsList(minVehicleCount?: number | null | undefined, maxVehicleCount?: number | null | undefined, minAverageSpeed?: number | null | undefined, maxAverageSpeed?: number | null | undefined, speedStatuses?: string[] | null | undefined, cities?: string[] | null | undefined, page?: number | undefined, size?: number | undefined, keyword?: string | undefined, sortBy?: string | undefined, sortOrder?: string | undefined, startDate?: Date | null | undefined, endDate?: Date | null | undefined, stationIds?: number[] | null | undefined, deviceSerials?: string[] | null | undefined, cancelToken?: CancelToken): Promise<ResultOfPagedResponseOfTrafficRecordListResponse> {
        let url_ = this.baseUrl + "/api/traffic-records?";
        if (minVehicleCount !== undefined && minVehicleCount !== null)
            url_ += "MinVehicleCount=" + encodeURIComponent("" + minVehicleCount) + "&";
        if (maxVehicleCount !== undefined && maxVehicleCount !== null)
            url_ += "MaxVehicleCount=" + encodeURIComponent("" + maxVehicleCount) + "&";
        if (minAverageSpeed !== undefined && minAverageSpeed !== null)
            url_ += "MinAverageSpeed=" + encodeURIComponent("" + minAverageSpeed) + "&";
        if (maxAverageSpeed !== undefined && maxAverageSpeed !== null)
            url_ += "MaxAverageSpeed=" + encodeURIComponent("" + maxAverageSpeed) + "&";
        if (speedStatuses !== undefined && speedStatuses !== null)
            speedStatuses && speedStatuses.forEach(item => { url_ += "SpeedStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (cities !== undefined && cities !== null)
            cities && cities.forEach(item => { url_ += "Cities=" + encodeURIComponent("" + item) + "&"; });
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new globalThis.Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (keyword === null)
            throw new globalThis.Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sortBy === null)
            throw new globalThis.Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortOrder === null)
            throw new globalThis.Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (stationIds !== undefined && stationIds !== null)
            stationIds && stationIds.forEach(item => { url_ += "StationIds=" + encodeURIComponent("" + item) + "&"; });
        if (deviceSerials !== undefined && deviceSerials !== null)
            deviceSerials && deviceSerials.forEach(item => { url_ += "DeviceSerials=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRecordsList(_response);
        });
    }

    protected processGetRecordsList(response: AxiosResponse): Promise<ResultOfPagedResponseOfTrafficRecordListResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultOfPagedResponseOfTrafficRecordListResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<ResultOfPagedResponseOfTrafficRecordListResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ResultOfPagedResponseOfTrafficRecordListResponse.fromJS(resultData400, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ResultOfPagedResponseOfTrafficRecordListResponse.fromJS(resultData403, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ResultOfPagedResponseOfTrafficRecordListResponse.fromJS(resultData500, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultOfPagedResponseOfTrafficRecordListResponse>(null as any);
    }

    getRecordsCount(keyword?: string | undefined, availableStationIds?: number[] | null | undefined, cancelToken?: CancelToken): Promise<ResultOfInteger> {
        let url_ = this.baseUrl + "/api/traffic-records-count?";
        if (keyword === null)
            throw new globalThis.Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        if (availableStationIds !== undefined && availableStationIds !== null)
            availableStationIds && availableStationIds.forEach(item => { url_ += "availableStationIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRecordsCount(_response);
        });
    }

    protected processGetRecordsCount(response: AxiosResponse): Promise<ResultOfInteger> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultOfInteger.fromJS(resultData200, _mappings);
            return Promise.resolve<ResultOfInteger>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiErrorResponse.fromJS(resultData400, _mappings);
            return throwException("\u9a57\u8b49\u5931\u6557\u6216\u8acb\u6c42\u683c\u5f0f\u932f\u8aa4", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ResultOfInteger.fromJS(resultData500, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultOfInteger>(null as any);
    }

    exportRecords(keyword?: string | undefined, stationIds?: number[] | null | undefined, startDate?: Date | null | undefined, endDate?: Date | null | undefined, format?: string | undefined, cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/traffic-records-export?";
        if (keyword === null)
            throw new globalThis.Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        if (stationIds !== undefined && stationIds !== null)
            stationIds && stationIds.forEach(item => { url_ += "stationIds=" + encodeURIComponent("" + item) + "&"; });
        if (startDate !== undefined && startDate !== null)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (format === null)
            throw new globalThis.Error("The parameter 'format' cannot be null.");
        else if (format !== undefined)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportRecords(_response);
        });
    }

    protected processExportRecords(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = Result.fromJS(resultData500, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getRecentRoadConditionHistory(stationID?: number | undefined, timeRange?: number | undefined, cancelToken?: CancelToken): Promise<TrafficRoadConditionHistoryResponse> {
        let url_ = this.baseUrl + "/api/overview/traffic/recent-road-condition-history?";
        if (stationID === null)
            throw new globalThis.Error("The parameter 'stationID' cannot be null.");
        else if (stationID !== undefined)
            url_ += "stationID=" + encodeURIComponent("" + stationID) + "&";
        if (timeRange === null)
            throw new globalThis.Error("The parameter 'timeRange' cannot be null.");
        else if (timeRange !== undefined)
            url_ += "timeRange=" + encodeURIComponent("" + timeRange) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRecentRoadConditionHistory(_response);
        });
    }

    protected processGetRecentRoadConditionHistory(response: AxiosResponse): Promise<TrafficRoadConditionHistoryResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TrafficRoadConditionHistoryResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<TrafficRoadConditionHistoryResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TrafficRoadConditionHistoryResponse>(null as any);
    }

    getRecentRoadCondition(stationID?: number | undefined, timeRange?: number | undefined, limit?: number | undefined, cancelToken?: CancelToken): Promise<TrafficRoadConditionResponse> {
        let url_ = this.baseUrl + "/api/overview/traffic/recent-road-condition?";
        if (stationID === null)
            throw new globalThis.Error("The parameter 'stationID' cannot be null.");
        else if (stationID !== undefined)
            url_ += "stationID=" + encodeURIComponent("" + stationID) + "&";
        if (timeRange === null)
            throw new globalThis.Error("The parameter 'timeRange' cannot be null.");
        else if (timeRange !== undefined)
            url_ += "timeRange=" + encodeURIComponent("" + timeRange) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRecentRoadCondition(_response);
        });
    }

    protected processGetRecentRoadCondition(response: AxiosResponse): Promise<TrafficRoadConditionResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TrafficRoadConditionResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<TrafficRoadConditionResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TrafficRoadConditionResponse>(null as any);
    }
}

export interface IHighResolutionClient {
    getOverviewInfo(stationID?: number | undefined,  cancelToken?: CancelToken): Promise<HighResolutionOverviewResponse>;
}

export class HighResolutionClient implements IHighResolutionClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "https://localhost:7289";

    }

    getOverviewInfo(stationID?: number | undefined, cancelToken?: CancelToken): Promise<HighResolutionOverviewResponse> {
        let url_ = this.baseUrl + "/api/overview/highResolution?";
        if (stationID === null)
            throw new globalThis.Error("The parameter 'stationID' cannot be null.");
        else if (stationID !== undefined)
            url_ += "stationID=" + encodeURIComponent("" + stationID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOverviewInfo(_response);
        });
    }

    protected processGetOverviewInfo(response: AxiosResponse): Promise<HighResolutionOverviewResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = HighResolutionOverviewResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<HighResolutionOverviewResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<HighResolutionOverviewResponse>(null as any);
    }
}

export class UserResponse implements IUserResponse {
    id?: string;
    name?: string;
    username?: string;
    email?: string;
    role?: string;
    phone?: string | null;
    employeeId?: string | null;
    isReadOnly?: boolean;
    stationIds?: number[] | null;

    constructor(data?: IUserResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.username = _data["username"] !== undefined ? _data["username"] : null as any;
            this.email = _data["email"] !== undefined ? _data["email"] : null as any;
            this.role = _data["role"] !== undefined ? _data["role"] : null as any;
            this.phone = _data["phone"] !== undefined ? _data["phone"] : null as any;
            this.employeeId = _data["employeeId"] !== undefined ? _data["employeeId"] : null as any;
            this.isReadOnly = _data["isReadOnly"] !== undefined ? _data["isReadOnly"] : null as any;
            if (Array.isArray(_data["stationIds"])) {
                this.stationIds = [] as any;
                for (let item of _data["stationIds"])
                    this.stationIds!.push(item);
            }
            else {
                this.stationIds = null as any;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): UserResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<UserResponse>(data, _mappings, UserResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["username"] = this.username !== undefined ? this.username : null as any;
        data["email"] = this.email !== undefined ? this.email : null as any;
        data["role"] = this.role !== undefined ? this.role : null as any;
        data["phone"] = this.phone !== undefined ? this.phone : null as any;
        data["employeeId"] = this.employeeId !== undefined ? this.employeeId : null as any;
        data["isReadOnly"] = this.isReadOnly !== undefined ? this.isReadOnly : null as any;
        if (Array.isArray(this.stationIds)) {
            data["stationIds"] = [];
            for (let item of this.stationIds)
                data["stationIds"].push(item);
        }
        return data;
    }
}

export interface IUserResponse {
    id?: string;
    name?: string;
    username?: string;
    email?: string;
    role?: string;
    phone?: string | null;
    employeeId?: string | null;
    isReadOnly?: boolean;
    stationIds?: number[] | null;
}

export class ApiErrorResponse implements IApiErrorResponse {
    errorCode?: string;
    message?: string;
    details?: string | null;
    validationErrors?: { [key: string]: string[]; } | null;
    timestamp?: Date;
    path?: string | null;
    statusCode?: number;

    constructor(data?: IApiErrorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.errorCode = _data["errorCode"] !== undefined ? _data["errorCode"] : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
            this.details = _data["details"] !== undefined ? _data["details"] : null as any;
            if (_data["validationErrors"]) {
                this.validationErrors = {} as any;
                for (let key in _data["validationErrors"]) {
                    if (_data["validationErrors"].hasOwnProperty(key))
                        (this.validationErrors as any)![key] = _data["validationErrors"][key] !== undefined ? _data["validationErrors"][key] : [];
                }
            }
            else {
                this.validationErrors = null as any;
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : null as any;
            this.path = _data["path"] !== undefined ? _data["path"] : null as any;
            this.statusCode = _data["statusCode"] !== undefined ? _data["statusCode"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): ApiErrorResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ApiErrorResponse>(data, _mappings, ApiErrorResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorCode"] = this.errorCode !== undefined ? this.errorCode : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        data["details"] = this.details !== undefined ? this.details : null as any;
        if (this.validationErrors) {
            data["validationErrors"] = {};
            for (let key in this.validationErrors) {
                if (this.validationErrors.hasOwnProperty(key))
                    (data["validationErrors"] as any)[key] = this.validationErrors[key] !== undefined ? this.validationErrors[key] : null as any;
            }
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : null as any;
        data["path"] = this.path !== undefined ? this.path : null as any;
        data["statusCode"] = this.statusCode !== undefined ? this.statusCode : null as any;
        return data;
    }
}

export interface IApiErrorResponse {
    errorCode?: string;
    message?: string;
    details?: string | null;
    validationErrors?: { [key: string]: string[]; } | null;
    timestamp?: Date;
    path?: string | null;
    statusCode?: number;
}

export class CountResponse implements ICountResponse {
    count?: number;

    constructor(data?: ICountResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"] !== undefined ? _data["count"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): CountResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CountResponse>(data, _mappings, CountResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count !== undefined ? this.count : null as any;
        return data;
    }
}

export interface ICountResponse {
    count?: number;
}

export class CreateAccountRequest implements ICreateAccountRequest {
    name!: string;
    username?: string | null;
    password?: string | null;
    role?: string | null;
    phone?: string | null;
    employeeId!: string;
    avatarUrl?: string | null;
    isReadOnly?: boolean;
    stationIds?: number[] | null;

    constructor(data?: ICreateAccountRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.username = _data["username"] !== undefined ? _data["username"] : null as any;
            this.password = _data["password"] !== undefined ? _data["password"] : null as any;
            this.role = _data["role"] !== undefined ? _data["role"] : null as any;
            this.phone = _data["phone"] !== undefined ? _data["phone"] : null as any;
            this.employeeId = _data["employeeId"] !== undefined ? _data["employeeId"] : null as any;
            this.avatarUrl = _data["avatarUrl"] !== undefined ? _data["avatarUrl"] : null as any;
            this.isReadOnly = _data["isReadOnly"] !== undefined ? _data["isReadOnly"] : null as any;
            if (Array.isArray(_data["stationIds"])) {
                this.stationIds = [] as any;
                for (let item of _data["stationIds"])
                    this.stationIds!.push(item);
            }
            else {
                this.stationIds = null as any;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): CreateAccountRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CreateAccountRequest>(data, _mappings, CreateAccountRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["username"] = this.username !== undefined ? this.username : null as any;
        data["password"] = this.password !== undefined ? this.password : null as any;
        data["role"] = this.role !== undefined ? this.role : null as any;
        data["phone"] = this.phone !== undefined ? this.phone : null as any;
        data["employeeId"] = this.employeeId !== undefined ? this.employeeId : null as any;
        data["avatarUrl"] = this.avatarUrl !== undefined ? this.avatarUrl : null as any;
        data["isReadOnly"] = this.isReadOnly !== undefined ? this.isReadOnly : null as any;
        if (Array.isArray(this.stationIds)) {
            data["stationIds"] = [];
            for (let item of this.stationIds)
                data["stationIds"].push(item);
        }
        return data;
    }
}

export interface ICreateAccountRequest {
    name: string;
    username?: string | null;
    password?: string | null;
    role?: string | null;
    phone?: string | null;
    employeeId: string;
    avatarUrl?: string | null;
    isReadOnly?: boolean;
    stationIds?: number[] | null;
}

export class UpdateAccountRequest implements IUpdateAccountRequest {
    name?: string | null;
    username?: string | null;
    password?: string | null;
    role?: string | null;
    phone?: string | null;
    employeeId?: string | null;
    avatarUrl?: string | null;
    isReadOnly?: boolean | null;
    stationIds?: number[] | null;

    constructor(data?: IUpdateAccountRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.username = _data["username"] !== undefined ? _data["username"] : null as any;
            this.password = _data["password"] !== undefined ? _data["password"] : null as any;
            this.role = _data["role"] !== undefined ? _data["role"] : null as any;
            this.phone = _data["phone"] !== undefined ? _data["phone"] : null as any;
            this.employeeId = _data["employeeId"] !== undefined ? _data["employeeId"] : null as any;
            this.avatarUrl = _data["avatarUrl"] !== undefined ? _data["avatarUrl"] : null as any;
            this.isReadOnly = _data["isReadOnly"] !== undefined ? _data["isReadOnly"] : null as any;
            if (Array.isArray(_data["stationIds"])) {
                this.stationIds = [] as any;
                for (let item of _data["stationIds"])
                    this.stationIds!.push(item);
            }
            else {
                this.stationIds = null as any;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): UpdateAccountRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<UpdateAccountRequest>(data, _mappings, UpdateAccountRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["username"] = this.username !== undefined ? this.username : null as any;
        data["password"] = this.password !== undefined ? this.password : null as any;
        data["role"] = this.role !== undefined ? this.role : null as any;
        data["phone"] = this.phone !== undefined ? this.phone : null as any;
        data["employeeId"] = this.employeeId !== undefined ? this.employeeId : null as any;
        data["avatarUrl"] = this.avatarUrl !== undefined ? this.avatarUrl : null as any;
        data["isReadOnly"] = this.isReadOnly !== undefined ? this.isReadOnly : null as any;
        if (Array.isArray(this.stationIds)) {
            data["stationIds"] = [];
            for (let item of this.stationIds)
                data["stationIds"].push(item);
        }
        return data;
    }
}

export interface IUpdateAccountRequest {
    name?: string | null;
    username?: string | null;
    password?: string | null;
    role?: string | null;
    phone?: string | null;
    employeeId?: string | null;
    avatarUrl?: string | null;
    isReadOnly?: boolean | null;
    stationIds?: number[] | null;
}

export class LoginResponse implements ILoginResponse {
    token?: string;
    user?: UserResponse;

    constructor(data?: ILoginResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.token = _data["token"] !== undefined ? _data["token"] : null as any;
            this.user = _data["user"] ? UserResponse.fromJS(_data["user"], _mappings) : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): LoginResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<LoginResponse>(data, _mappings, LoginResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token !== undefined ? this.token : null as any;
        data["user"] = this.user ? this.user.toJSON() : null as any;
        return data;
    }
}

export interface ILoginResponse {
    token?: string;
    user?: UserResponse;
}

export class LoginRequest implements ILoginRequest {
    username!: string;
    password!: string;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.username = _data["username"] !== undefined ? _data["username"] : null as any;
            this.password = _data["password"] !== undefined ? _data["password"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): LoginRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<LoginRequest>(data, _mappings, LoginRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : null as any;
        data["password"] = this.password !== undefined ? this.password : null as any;
        return data;
    }
}

export interface ILoginRequest {
    username: string;
    password: string;
}

export class ProfileResponse implements IProfileResponse {
    name?: string;
    username?: string | null;
    role?: string;
    phone?: string | null;
    employeeID?: string | null;
    avatarUrl?: string | null;
    isReadOnly?: boolean;
    stationIds?: number[] | null;

    constructor(data?: IProfileResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.username = _data["username"] !== undefined ? _data["username"] : null as any;
            this.role = _data["role"] !== undefined ? _data["role"] : null as any;
            this.phone = _data["phone"] !== undefined ? _data["phone"] : null as any;
            this.employeeID = _data["employeeID"] !== undefined ? _data["employeeID"] : null as any;
            this.avatarUrl = _data["avatarUrl"] !== undefined ? _data["avatarUrl"] : null as any;
            this.isReadOnly = _data["isReadOnly"] !== undefined ? _data["isReadOnly"] : null as any;
            if (Array.isArray(_data["stationIds"])) {
                this.stationIds = [] as any;
                for (let item of _data["stationIds"])
                    this.stationIds!.push(item);
            }
            else {
                this.stationIds = null as any;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): ProfileResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ProfileResponse>(data, _mappings, ProfileResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["username"] = this.username !== undefined ? this.username : null as any;
        data["role"] = this.role !== undefined ? this.role : null as any;
        data["phone"] = this.phone !== undefined ? this.phone : null as any;
        data["employeeID"] = this.employeeID !== undefined ? this.employeeID : null as any;
        data["avatarUrl"] = this.avatarUrl !== undefined ? this.avatarUrl : null as any;
        data["isReadOnly"] = this.isReadOnly !== undefined ? this.isReadOnly : null as any;
        if (Array.isArray(this.stationIds)) {
            data["stationIds"] = [];
            for (let item of this.stationIds)
                data["stationIds"].push(item);
        }
        return data;
    }
}

export interface IProfileResponse {
    name?: string;
    username?: string | null;
    role?: string;
    phone?: string | null;
    employeeID?: string | null;
    avatarUrl?: string | null;
    isReadOnly?: boolean;
    stationIds?: number[] | null;
}

export class DeviceListResponse implements IDeviceListResponse {
    type?: string;
    id?: number;
    name?: string;
    lat?: number;
    lng?: number;
    stationID?: number;
    serial?: string;
    stationName?: string;
    status?: string | null;
    latestOnlineTime?: string | null;
    updatedAt?: string | null;
    area?: number;
    videoUrl?: string | null;
    apiUrl?: string | null;
    numberOfParking?: number;
    city?: string | null;
    eTagNumber?: string | null;
    speedLimit?: number;
    observingTimeStart?: string | null;
    observingTimeEnd?: string | null;
    zones?: string | null;
    cameraConfig?: string | null;

    constructor(data?: IDeviceListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.type = _data["type"] !== undefined ? _data["type"] : null as any;
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.lat = _data["lat"] !== undefined ? _data["lat"] : null as any;
            this.lng = _data["lng"] !== undefined ? _data["lng"] : null as any;
            this.stationID = _data["stationID"] !== undefined ? _data["stationID"] : null as any;
            this.serial = _data["serial"] !== undefined ? _data["serial"] : null as any;
            this.stationName = _data["stationName"] !== undefined ? _data["stationName"] : null as any;
            this.status = _data["status"] !== undefined ? _data["status"] : null as any;
            this.latestOnlineTime = _data["latestOnlineTime"] !== undefined ? _data["latestOnlineTime"] : null as any;
            this.updatedAt = _data["updatedAt"] !== undefined ? _data["updatedAt"] : null as any;
            this.area = _data["area"] !== undefined ? _data["area"] : null as any;
            this.videoUrl = _data["videoUrl"] !== undefined ? _data["videoUrl"] : null as any;
            this.apiUrl = _data["apiUrl"] !== undefined ? _data["apiUrl"] : null as any;
            this.numberOfParking = _data["numberOfParking"] !== undefined ? _data["numberOfParking"] : null as any;
            this.city = _data["city"] !== undefined ? _data["city"] : null as any;
            this.eTagNumber = _data["eTagNumber"] !== undefined ? _data["eTagNumber"] : null as any;
            this.speedLimit = _data["speedLimit"] !== undefined ? _data["speedLimit"] : null as any;
            this.observingTimeStart = _data["observingTimeStart"] !== undefined ? _data["observingTimeStart"] : null as any;
            this.observingTimeEnd = _data["observingTimeEnd"] !== undefined ? _data["observingTimeEnd"] : null as any;
            this.zones = _data["zones"] !== undefined ? _data["zones"] : null as any;
            this.cameraConfig = _data["cameraConfig"] !== undefined ? _data["cameraConfig"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): DeviceListResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<DeviceListResponse>(data, _mappings, DeviceListResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type !== undefined ? this.type : null as any;
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["lat"] = this.lat !== undefined ? this.lat : null as any;
        data["lng"] = this.lng !== undefined ? this.lng : null as any;
        data["stationID"] = this.stationID !== undefined ? this.stationID : null as any;
        data["serial"] = this.serial !== undefined ? this.serial : null as any;
        data["stationName"] = this.stationName !== undefined ? this.stationName : null as any;
        data["status"] = this.status !== undefined ? this.status : null as any;
        data["latestOnlineTime"] = this.latestOnlineTime !== undefined ? this.latestOnlineTime : null as any;
        data["updatedAt"] = this.updatedAt !== undefined ? this.updatedAt : null as any;
        data["area"] = this.area !== undefined ? this.area : null as any;
        data["videoUrl"] = this.videoUrl !== undefined ? this.videoUrl : null as any;
        data["apiUrl"] = this.apiUrl !== undefined ? this.apiUrl : null as any;
        data["numberOfParking"] = this.numberOfParking !== undefined ? this.numberOfParking : null as any;
        data["city"] = this.city !== undefined ? this.city : null as any;
        data["eTagNumber"] = this.eTagNumber !== undefined ? this.eTagNumber : null as any;
        data["speedLimit"] = this.speedLimit !== undefined ? this.speedLimit : null as any;
        data["observingTimeStart"] = this.observingTimeStart !== undefined ? this.observingTimeStart : null as any;
        data["observingTimeEnd"] = this.observingTimeEnd !== undefined ? this.observingTimeEnd : null as any;
        data["zones"] = this.zones !== undefined ? this.zones : null as any;
        data["cameraConfig"] = this.cameraConfig !== undefined ? this.cameraConfig : null as any;
        return data;
    }
}

export interface IDeviceListResponse {
    type?: string;
    id?: number;
    name?: string;
    lat?: number;
    lng?: number;
    stationID?: number;
    serial?: string;
    stationName?: string;
    status?: string | null;
    latestOnlineTime?: string | null;
    updatedAt?: string | null;
    area?: number;
    videoUrl?: string | null;
    apiUrl?: string | null;
    numberOfParking?: number;
    city?: string | null;
    eTagNumber?: string | null;
    speedLimit?: number;
    observingTimeStart?: string | null;
    observingTimeEnd?: string | null;
    zones?: string | null;
    cameraConfig?: string | null;
}

export class CreateDeviceRequest implements ICreateDeviceRequest {
    type!: string;
    stationID!: number;
    name!: string;
    lng!: number;
    lat!: number;
    serial!: string;
    area?: number | null;
    videoUrl?: string | null;
    apiUrl?: string | null;
    numberOfParking?: number | null;
    city?: string | null;
    eTagNumber?: string | null;
    speedLimit?: number | null;
    observingTimeStart?: string | null;
    observingTimeEnd?: string | null;
    cameraConfig?: string | null;

    constructor(data?: ICreateDeviceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.type = _data["type"] !== undefined ? _data["type"] : null as any;
            this.stationID = _data["stationID"] !== undefined ? _data["stationID"] : null as any;
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.lng = _data["lng"] !== undefined ? _data["lng"] : null as any;
            this.lat = _data["lat"] !== undefined ? _data["lat"] : null as any;
            this.serial = _data["serial"] !== undefined ? _data["serial"] : null as any;
            this.area = _data["area"] !== undefined ? _data["area"] : null as any;
            this.videoUrl = _data["videoUrl"] !== undefined ? _data["videoUrl"] : null as any;
            this.apiUrl = _data["apiUrl"] !== undefined ? _data["apiUrl"] : null as any;
            this.numberOfParking = _data["numberOfParking"] !== undefined ? _data["numberOfParking"] : null as any;
            this.city = _data["city"] !== undefined ? _data["city"] : null as any;
            this.eTagNumber = _data["eTagNumber"] !== undefined ? _data["eTagNumber"] : null as any;
            this.speedLimit = _data["speedLimit"] !== undefined ? _data["speedLimit"] : null as any;
            this.observingTimeStart = _data["observingTimeStart"] !== undefined ? _data["observingTimeStart"] : null as any;
            this.observingTimeEnd = _data["observingTimeEnd"] !== undefined ? _data["observingTimeEnd"] : null as any;
            this.cameraConfig = _data["cameraConfig"] !== undefined ? _data["cameraConfig"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): CreateDeviceRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CreateDeviceRequest>(data, _mappings, CreateDeviceRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type !== undefined ? this.type : null as any;
        data["stationID"] = this.stationID !== undefined ? this.stationID : null as any;
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["lng"] = this.lng !== undefined ? this.lng : null as any;
        data["lat"] = this.lat !== undefined ? this.lat : null as any;
        data["serial"] = this.serial !== undefined ? this.serial : null as any;
        data["area"] = this.area !== undefined ? this.area : null as any;
        data["videoUrl"] = this.videoUrl !== undefined ? this.videoUrl : null as any;
        data["apiUrl"] = this.apiUrl !== undefined ? this.apiUrl : null as any;
        data["numberOfParking"] = this.numberOfParking !== undefined ? this.numberOfParking : null as any;
        data["city"] = this.city !== undefined ? this.city : null as any;
        data["eTagNumber"] = this.eTagNumber !== undefined ? this.eTagNumber : null as any;
        data["speedLimit"] = this.speedLimit !== undefined ? this.speedLimit : null as any;
        data["observingTimeStart"] = this.observingTimeStart !== undefined ? this.observingTimeStart : null as any;
        data["observingTimeEnd"] = this.observingTimeEnd !== undefined ? this.observingTimeEnd : null as any;
        data["cameraConfig"] = this.cameraConfig !== undefined ? this.cameraConfig : null as any;
        return data;
    }
}

export interface ICreateDeviceRequest {
    type: string;
    stationID: number;
    name: string;
    lng: number;
    lat: number;
    serial: string;
    area?: number | null;
    videoUrl?: string | null;
    apiUrl?: string | null;
    numberOfParking?: number | null;
    city?: string | null;
    eTagNumber?: string | null;
    speedLimit?: number | null;
    observingTimeStart?: string | null;
    observingTimeEnd?: string | null;
    cameraConfig?: string | null;
}

export class UpdateDeviceRequest implements IUpdateDeviceRequest {
    type!: string;
    name!: string;
    lng!: number;
    lat!: number;
    serial!: string;
    area?: number | null;
    videoUrl?: string | null;
    apiUrl?: string | null;
    numberOfParking?: number | null;
    city?: string | null;
    eTagNumber?: string | null;
    speedLimit?: number | null;
    observingTimeStart?: string | null;
    observingTimeEnd?: string | null;
    cameraConfig?: string | null;

    constructor(data?: IUpdateDeviceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.type = _data["type"] !== undefined ? _data["type"] : null as any;
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.lng = _data["lng"] !== undefined ? _data["lng"] : null as any;
            this.lat = _data["lat"] !== undefined ? _data["lat"] : null as any;
            this.serial = _data["serial"] !== undefined ? _data["serial"] : null as any;
            this.area = _data["area"] !== undefined ? _data["area"] : null as any;
            this.videoUrl = _data["videoUrl"] !== undefined ? _data["videoUrl"] : null as any;
            this.apiUrl = _data["apiUrl"] !== undefined ? _data["apiUrl"] : null as any;
            this.numberOfParking = _data["numberOfParking"] !== undefined ? _data["numberOfParking"] : null as any;
            this.city = _data["city"] !== undefined ? _data["city"] : null as any;
            this.eTagNumber = _data["eTagNumber"] !== undefined ? _data["eTagNumber"] : null as any;
            this.speedLimit = _data["speedLimit"] !== undefined ? _data["speedLimit"] : null as any;
            this.observingTimeStart = _data["observingTimeStart"] !== undefined ? _data["observingTimeStart"] : null as any;
            this.observingTimeEnd = _data["observingTimeEnd"] !== undefined ? _data["observingTimeEnd"] : null as any;
            this.cameraConfig = _data["cameraConfig"] !== undefined ? _data["cameraConfig"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): UpdateDeviceRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<UpdateDeviceRequest>(data, _mappings, UpdateDeviceRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type !== undefined ? this.type : null as any;
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["lng"] = this.lng !== undefined ? this.lng : null as any;
        data["lat"] = this.lat !== undefined ? this.lat : null as any;
        data["serial"] = this.serial !== undefined ? this.serial : null as any;
        data["area"] = this.area !== undefined ? this.area : null as any;
        data["videoUrl"] = this.videoUrl !== undefined ? this.videoUrl : null as any;
        data["apiUrl"] = this.apiUrl !== undefined ? this.apiUrl : null as any;
        data["numberOfParking"] = this.numberOfParking !== undefined ? this.numberOfParking : null as any;
        data["city"] = this.city !== undefined ? this.city : null as any;
        data["eTagNumber"] = this.eTagNumber !== undefined ? this.eTagNumber : null as any;
        data["speedLimit"] = this.speedLimit !== undefined ? this.speedLimit : null as any;
        data["observingTimeStart"] = this.observingTimeStart !== undefined ? this.observingTimeStart : null as any;
        data["observingTimeEnd"] = this.observingTimeEnd !== undefined ? this.observingTimeEnd : null as any;
        data["cameraConfig"] = this.cameraConfig !== undefined ? this.cameraConfig : null as any;
        return data;
    }
}

export interface IUpdateDeviceRequest {
    type: string;
    name: string;
    lng: number;
    lat: number;
    serial: string;
    area?: number | null;
    videoUrl?: string | null;
    apiUrl?: string | null;
    numberOfParking?: number | null;
    city?: string | null;
    eTagNumber?: string | null;
    speedLimit?: number | null;
    observingTimeStart?: string | null;
    observingTimeEnd?: string | null;
    cameraConfig?: string | null;
}

export class DeviceStatusResponse implements IDeviceStatusResponse {
    id?: number;
    name?: string;
    serial?: string;
    status?: string;
    latestOnlineTime?: string | null;
    stationName?: string;
    type?: string;

    constructor(data?: IDeviceStatusResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.serial = _data["serial"] !== undefined ? _data["serial"] : null as any;
            this.status = _data["status"] !== undefined ? _data["status"] : null as any;
            this.latestOnlineTime = _data["latestOnlineTime"] !== undefined ? _data["latestOnlineTime"] : null as any;
            this.stationName = _data["stationName"] !== undefined ? _data["stationName"] : null as any;
            this.type = _data["type"] !== undefined ? _data["type"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): DeviceStatusResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<DeviceStatusResponse>(data, _mappings, DeviceStatusResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["serial"] = this.serial !== undefined ? this.serial : null as any;
        data["status"] = this.status !== undefined ? this.status : null as any;
        data["latestOnlineTime"] = this.latestOnlineTime !== undefined ? this.latestOnlineTime : null as any;
        data["stationName"] = this.stationName !== undefined ? this.stationName : null as any;
        data["type"] = this.type !== undefined ? this.type : null as any;
        return data;
    }
}

export interface IDeviceStatusResponse {
    id?: number;
    name?: string;
    serial?: string;
    status?: string;
    latestOnlineTime?: string | null;
    stationName?: string;
    type?: string;
}

export class DeviceStatusLogResponse implements IDeviceStatusLogResponse {
    id?: number;
    deviceType?: string;
    deviceSerial?: string;
    status?: string;
    time?: string;
    deviceName?: string;
    stationName?: string;

    constructor(data?: IDeviceStatusLogResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.deviceType = _data["deviceType"] !== undefined ? _data["deviceType"] : null as any;
            this.deviceSerial = _data["deviceSerial"] !== undefined ? _data["deviceSerial"] : null as any;
            this.status = _data["status"] !== undefined ? _data["status"] : null as any;
            this.time = _data["time"] !== undefined ? _data["time"] : null as any;
            this.deviceName = _data["deviceName"] !== undefined ? _data["deviceName"] : null as any;
            this.stationName = _data["stationName"] !== undefined ? _data["stationName"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): DeviceStatusLogResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<DeviceStatusLogResponse>(data, _mappings, DeviceStatusLogResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["deviceType"] = this.deviceType !== undefined ? this.deviceType : null as any;
        data["deviceSerial"] = this.deviceSerial !== undefined ? this.deviceSerial : null as any;
        data["status"] = this.status !== undefined ? this.status : null as any;
        data["time"] = this.time !== undefined ? this.time : null as any;
        data["deviceName"] = this.deviceName !== undefined ? this.deviceName : null as any;
        data["stationName"] = this.stationName !== undefined ? this.stationName : null as any;
        return data;
    }
}

export interface IDeviceStatusLogResponse {
    id?: number;
    deviceType?: string;
    deviceSerial?: string;
    status?: string;
    time?: string;
    deviceName?: string;
    stationName?: string;
}

export class ExternalAlertResponse implements IExternalAlertResponse {
    message?: string;

    constructor(data?: IExternalAlertResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): ExternalAlertResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ExternalAlertResponse>(data, _mappings, ExternalAlertResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message !== undefined ? this.message : null as any;
        return data;
    }
}

export interface IExternalAlertResponse {
    message?: string;
}

export class ExternalAlertDto implements IExternalAlertDto {
    source?: string;
    alertType?: string;
    status?: string;
    camera?: string;
    message?: string;
    snapshot?: string | null;
    timestamp?: string;

    constructor(data?: IExternalAlertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.source = _data["source"] !== undefined ? _data["source"] : null as any;
            this.alertType = _data["alertType"] !== undefined ? _data["alertType"] : null as any;
            this.status = _data["status"] !== undefined ? _data["status"] : null as any;
            this.camera = _data["camera"] !== undefined ? _data["camera"] : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
            this.snapshot = _data["snapshot"] !== undefined ? _data["snapshot"] : null as any;
            this.timestamp = _data["timestamp"] !== undefined ? _data["timestamp"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): ExternalAlertDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ExternalAlertDto>(data, _mappings, ExternalAlertDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["source"] = this.source !== undefined ? this.source : null as any;
        data["alertType"] = this.alertType !== undefined ? this.alertType : null as any;
        data["status"] = this.status !== undefined ? this.status : null as any;
        data["camera"] = this.camera !== undefined ? this.camera : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        data["snapshot"] = this.snapshot !== undefined ? this.snapshot : null as any;
        data["timestamp"] = this.timestamp !== undefined ? this.timestamp : null as any;
        return data;
    }
}

export interface IExternalAlertDto {
    source?: string;
    alertType?: string;
    status?: string;
    camera?: string;
    message?: string;
    snapshot?: string | null;
    timestamp?: string;
}

export class LandmarksResponse implements ILandmarksResponse {
    landmarks?: LandmarkItem[];

    constructor(data?: ILandmarksResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["landmarks"])) {
                this.landmarks = [] as any;
                for (let item of _data["landmarks"])
                    this.landmarks!.push(LandmarkItem.fromJS(item, _mappings));
            }
            else {
                this.landmarks = null as any;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): LandmarksResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<LandmarksResponse>(data, _mappings, LandmarksResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.landmarks)) {
            data["landmarks"] = [];
            for (let item of this.landmarks)
                data["landmarks"].push(item ? item.toJSON() : null as any);
        }
        return data;
    }
}

export interface ILandmarksResponse {
    landmarks?: LandmarkItem[];
}

export class LandmarkItem implements ILandmarkItem {
    id?: number;
    name?: string;
    lat?: number;
    lng?: number;
    type?: string;
    status?: string;
    serial?: string | null;
    stationID?: number;
    stationName?: string;
    latestOnlineTime?: string | null;
    updatedAt?: string | null;
    area?: number | null;
    numberOfParking?: number | null;
    speedLimit?: number | null;
    videoUrl?: string | null;
    observingTime?: string | null;

    constructor(data?: ILandmarkItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.lat = _data["lat"] !== undefined ? _data["lat"] : null as any;
            this.lng = _data["lng"] !== undefined ? _data["lng"] : null as any;
            this.type = _data["type"] !== undefined ? _data["type"] : null as any;
            this.status = _data["status"] !== undefined ? _data["status"] : null as any;
            this.serial = _data["serial"] !== undefined ? _data["serial"] : null as any;
            this.stationID = _data["stationID"] !== undefined ? _data["stationID"] : null as any;
            this.stationName = _data["stationName"] !== undefined ? _data["stationName"] : null as any;
            this.latestOnlineTime = _data["latestOnlineTime"] !== undefined ? _data["latestOnlineTime"] : null as any;
            this.updatedAt = _data["updatedAt"] !== undefined ? _data["updatedAt"] : null as any;
            this.area = _data["area"] !== undefined ? _data["area"] : null as any;
            this.numberOfParking = _data["numberOfParking"] !== undefined ? _data["numberOfParking"] : null as any;
            this.speedLimit = _data["speedLimit"] !== undefined ? _data["speedLimit"] : null as any;
            this.videoUrl = _data["videoUrl"] !== undefined ? _data["videoUrl"] : null as any;
            this.observingTime = _data["observingTime"] !== undefined ? _data["observingTime"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): LandmarkItem | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<LandmarkItem>(data, _mappings, LandmarkItem);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["lat"] = this.lat !== undefined ? this.lat : null as any;
        data["lng"] = this.lng !== undefined ? this.lng : null as any;
        data["type"] = this.type !== undefined ? this.type : null as any;
        data["status"] = this.status !== undefined ? this.status : null as any;
        data["serial"] = this.serial !== undefined ? this.serial : null as any;
        data["stationID"] = this.stationID !== undefined ? this.stationID : null as any;
        data["stationName"] = this.stationName !== undefined ? this.stationName : null as any;
        data["latestOnlineTime"] = this.latestOnlineTime !== undefined ? this.latestOnlineTime : null as any;
        data["updatedAt"] = this.updatedAt !== undefined ? this.updatedAt : null as any;
        data["area"] = this.area !== undefined ? this.area : null as any;
        data["numberOfParking"] = this.numberOfParking !== undefined ? this.numberOfParking : null as any;
        data["speedLimit"] = this.speedLimit !== undefined ? this.speedLimit : null as any;
        data["videoUrl"] = this.videoUrl !== undefined ? this.videoUrl : null as any;
        data["observingTime"] = this.observingTime !== undefined ? this.observingTime : null as any;
        return data;
    }
}

export interface ILandmarkItem {
    id?: number;
    name?: string;
    lat?: number;
    lng?: number;
    type?: string;
    status?: string;
    serial?: string | null;
    stationID?: number;
    stationName?: string;
    latestOnlineTime?: string | null;
    updatedAt?: string | null;
    area?: number | null;
    numberOfParking?: number | null;
    speedLimit?: number | null;
    videoUrl?: string | null;
    observingTime?: string | null;
}

export class ParkingLandmarkResponse implements IParkingLandmarkResponse {
    id?: number;
    name?: string;
    lat?: number;
    lng?: number;
    serial?: string;
    numberOfParking?: number;
    status?: string;
    latestRecord?: ParkingRecordInfo | null;
    currentParked?: number;
    availableSpaces?: number;
    occupancyRate?: number;
    historyDatas?: { [key: string]: number; } | null;
    lastUpdateTime?: string | null;

    constructor(data?: IParkingLandmarkResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.lat = _data["lat"] !== undefined ? _data["lat"] : null as any;
            this.lng = _data["lng"] !== undefined ? _data["lng"] : null as any;
            this.serial = _data["serial"] !== undefined ? _data["serial"] : null as any;
            this.numberOfParking = _data["numberOfParking"] !== undefined ? _data["numberOfParking"] : null as any;
            this.status = _data["status"] !== undefined ? _data["status"] : null as any;
            this.latestRecord = _data["latestRecord"] ? ParkingRecordInfo.fromJS(_data["latestRecord"], _mappings) : null as any;
            this.currentParked = _data["currentParked"] !== undefined ? _data["currentParked"] : null as any;
            this.availableSpaces = _data["availableSpaces"] !== undefined ? _data["availableSpaces"] : null as any;
            this.occupancyRate = _data["occupancyRate"] !== undefined ? _data["occupancyRate"] : null as any;
            if (_data["historyDatas"]) {
                this.historyDatas = {} as any;
                for (let key in _data["historyDatas"]) {
                    if (_data["historyDatas"].hasOwnProperty(key))
                        (this.historyDatas as any)![key] = _data["historyDatas"][key] !== undefined ? _data["historyDatas"][key] : null as any;
                }
            }
            else {
                this.historyDatas = null as any;
            }
            this.lastUpdateTime = _data["lastUpdateTime"] !== undefined ? _data["lastUpdateTime"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): ParkingLandmarkResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ParkingLandmarkResponse>(data, _mappings, ParkingLandmarkResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["lat"] = this.lat !== undefined ? this.lat : null as any;
        data["lng"] = this.lng !== undefined ? this.lng : null as any;
        data["serial"] = this.serial !== undefined ? this.serial : null as any;
        data["numberOfParking"] = this.numberOfParking !== undefined ? this.numberOfParking : null as any;
        data["status"] = this.status !== undefined ? this.status : null as any;
        data["latestRecord"] = this.latestRecord ? this.latestRecord.toJSON() : null as any;
        data["currentParked"] = this.currentParked !== undefined ? this.currentParked : null as any;
        data["availableSpaces"] = this.availableSpaces !== undefined ? this.availableSpaces : null as any;
        data["occupancyRate"] = this.occupancyRate !== undefined ? this.occupancyRate : null as any;
        if (this.historyDatas) {
            data["historyDatas"] = {};
            for (let key in this.historyDatas) {
                if (this.historyDatas.hasOwnProperty(key))
                    (data["historyDatas"] as any)[key] = this.historyDatas[key] !== undefined ? this.historyDatas[key] : null as any;
            }
        }
        data["lastUpdateTime"] = this.lastUpdateTime !== undefined ? this.lastUpdateTime : null as any;
        return data;
    }
}

export interface IParkingLandmarkResponse {
    id?: number;
    name?: string;
    lat?: number;
    lng?: number;
    serial?: string;
    numberOfParking?: number;
    status?: string;
    latestRecord?: ParkingRecordInfo | null;
    currentParked?: number;
    availableSpaces?: number;
    occupancyRate?: number;
    historyDatas?: { [key: string]: number; } | null;
    lastUpdateTime?: string | null;
}

export class ParkingRecordInfo implements IParkingRecordInfo {
    time?: number;
    parkedNum?: number;
    deviceSerial?: string;

    constructor(data?: IParkingRecordInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.time = _data["time"] !== undefined ? _data["time"] : null as any;
            this.parkedNum = _data["parkedNum"] !== undefined ? _data["parkedNum"] : null as any;
            this.deviceSerial = _data["deviceSerial"] !== undefined ? _data["deviceSerial"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): ParkingRecordInfo | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ParkingRecordInfo>(data, _mappings, ParkingRecordInfo);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time !== undefined ? this.time : null as any;
        data["parkedNum"] = this.parkedNum !== undefined ? this.parkedNum : null as any;
        data["deviceSerial"] = this.deviceSerial !== undefined ? this.deviceSerial : null as any;
        return data;
    }
}

export interface IParkingRecordInfo {
    time?: number;
    parkedNum?: number;
    deviceSerial?: string;
}

export class TrafficLandmarkResponse implements ITrafficLandmarkResponse {
    id?: number;
    name?: string;
    lat?: number;
    lng?: number;
    serial?: string;
    city?: string;
    eTagNumber?: string;
    speedLimit?: number;
    status?: string;
    congestionStatus?: string | null;
    latestRecord?: TrafficRecordInfo | null;
    currentVehicleCount?: number;
    currentAverageSpeed?: number;
    historyDatas?: { [key: string]: string; } | null;
    lastUpdateTime?: string | null;
    stationName?: string | null;

    constructor(data?: ITrafficLandmarkResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.lat = _data["lat"] !== undefined ? _data["lat"] : null as any;
            this.lng = _data["lng"] !== undefined ? _data["lng"] : null as any;
            this.serial = _data["serial"] !== undefined ? _data["serial"] : null as any;
            this.city = _data["city"] !== undefined ? _data["city"] : null as any;
            this.eTagNumber = _data["eTagNumber"] !== undefined ? _data["eTagNumber"] : null as any;
            this.speedLimit = _data["speedLimit"] !== undefined ? _data["speedLimit"] : null as any;
            this.status = _data["status"] !== undefined ? _data["status"] : null as any;
            this.congestionStatus = _data["congestionStatus"] !== undefined ? _data["congestionStatus"] : null as any;
            this.latestRecord = _data["latestRecord"] ? TrafficRecordInfo.fromJS(_data["latestRecord"], _mappings) : null as any;
            this.currentVehicleCount = _data["currentVehicleCount"] !== undefined ? _data["currentVehicleCount"] : null as any;
            this.currentAverageSpeed = _data["currentAverageSpeed"] !== undefined ? _data["currentAverageSpeed"] : null as any;
            if (_data["historyDatas"]) {
                this.historyDatas = {} as any;
                for (let key in _data["historyDatas"]) {
                    if (_data["historyDatas"].hasOwnProperty(key))
                        (this.historyDatas as any)![key] = _data["historyDatas"][key] !== undefined ? _data["historyDatas"][key] : null as any;
                }
            }
            else {
                this.historyDatas = null as any;
            }
            this.lastUpdateTime = _data["lastUpdateTime"] !== undefined ? _data["lastUpdateTime"] : null as any;
            this.stationName = _data["stationName"] !== undefined ? _data["stationName"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): TrafficLandmarkResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TrafficLandmarkResponse>(data, _mappings, TrafficLandmarkResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["lat"] = this.lat !== undefined ? this.lat : null as any;
        data["lng"] = this.lng !== undefined ? this.lng : null as any;
        data["serial"] = this.serial !== undefined ? this.serial : null as any;
        data["city"] = this.city !== undefined ? this.city : null as any;
        data["eTagNumber"] = this.eTagNumber !== undefined ? this.eTagNumber : null as any;
        data["speedLimit"] = this.speedLimit !== undefined ? this.speedLimit : null as any;
        data["status"] = this.status !== undefined ? this.status : null as any;
        data["congestionStatus"] = this.congestionStatus !== undefined ? this.congestionStatus : null as any;
        data["latestRecord"] = this.latestRecord ? this.latestRecord.toJSON() : null as any;
        data["currentVehicleCount"] = this.currentVehicleCount !== undefined ? this.currentVehicleCount : null as any;
        data["currentAverageSpeed"] = this.currentAverageSpeed !== undefined ? this.currentAverageSpeed : null as any;
        if (this.historyDatas) {
            data["historyDatas"] = {};
            for (let key in this.historyDatas) {
                if (this.historyDatas.hasOwnProperty(key))
                    (data["historyDatas"] as any)[key] = this.historyDatas[key] !== undefined ? this.historyDatas[key] : null as any;
            }
        }
        data["lastUpdateTime"] = this.lastUpdateTime !== undefined ? this.lastUpdateTime : null as any;
        data["stationName"] = this.stationName !== undefined ? this.stationName : null as any;
        return data;
    }
}

export interface ITrafficLandmarkResponse {
    id?: number;
    name?: string;
    lat?: number;
    lng?: number;
    serial?: string;
    city?: string;
    eTagNumber?: string;
    speedLimit?: number;
    status?: string;
    congestionStatus?: string | null;
    latestRecord?: TrafficRecordInfo | null;
    currentVehicleCount?: number;
    currentAverageSpeed?: number;
    historyDatas?: { [key: string]: string; } | null;
    lastUpdateTime?: string | null;
    stationName?: string | null;
}

export class TrafficRecordInfo implements ITrafficRecordInfo {
    time?: number;
    spaceMeanSpeed?: number;
    vehicleCount?: number;
    deviceSerial?: string;

    constructor(data?: ITrafficRecordInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.time = _data["time"] !== undefined ? _data["time"] : null as any;
            this.spaceMeanSpeed = _data["spaceMeanSpeed"] !== undefined ? _data["spaceMeanSpeed"] : null as any;
            this.vehicleCount = _data["vehicleCount"] !== undefined ? _data["vehicleCount"] : null as any;
            this.deviceSerial = _data["deviceSerial"] !== undefined ? _data["deviceSerial"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): TrafficRecordInfo | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TrafficRecordInfo>(data, _mappings, TrafficRecordInfo);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time !== undefined ? this.time : null as any;
        data["spaceMeanSpeed"] = this.spaceMeanSpeed !== undefined ? this.spaceMeanSpeed : null as any;
        data["vehicleCount"] = this.vehicleCount !== undefined ? this.vehicleCount : null as any;
        data["deviceSerial"] = this.deviceSerial !== undefined ? this.deviceSerial : null as any;
        return data;
    }
}

export interface ITrafficRecordInfo {
    time?: number;
    spaceMeanSpeed?: number;
    vehicleCount?: number;
    deviceSerial?: string;
}

export class CrowdLandmarkResponse implements ICrowdLandmarkResponse {
    id?: number;
    name?: string;
    lat?: number;
    lng?: number;
    serial?: string;
    area?: number;
    videoUrl?: string;
    apiUrl?: string;
    status?: string;
    congestionStatus?: string | null;
    latestRecord?: CrowdRecordInfo | null;
    currentPeopleCount?: number;
    crowdDensity?: number;
    historyDatas?: { [key: string]: number; } | null;
    lastUpdateTime?: string | null;
    totalIn?: number;

    constructor(data?: ICrowdLandmarkResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.lat = _data["lat"] !== undefined ? _data["lat"] : null as any;
            this.lng = _data["lng"] !== undefined ? _data["lng"] : null as any;
            this.serial = _data["serial"] !== undefined ? _data["serial"] : null as any;
            this.area = _data["area"] !== undefined ? _data["area"] : null as any;
            this.videoUrl = _data["videoUrl"] !== undefined ? _data["videoUrl"] : null as any;
            this.apiUrl = _data["apiUrl"] !== undefined ? _data["apiUrl"] : null as any;
            this.status = _data["status"] !== undefined ? _data["status"] : null as any;
            this.congestionStatus = _data["congestionStatus"] !== undefined ? _data["congestionStatus"] : null as any;
            this.latestRecord = _data["latestRecord"] ? CrowdRecordInfo.fromJS(_data["latestRecord"], _mappings) : null as any;
            this.currentPeopleCount = _data["currentPeopleCount"] !== undefined ? _data["currentPeopleCount"] : null as any;
            this.crowdDensity = _data["crowdDensity"] !== undefined ? _data["crowdDensity"] : null as any;
            if (_data["historyDatas"]) {
                this.historyDatas = {} as any;
                for (let key in _data["historyDatas"]) {
                    if (_data["historyDatas"].hasOwnProperty(key))
                        (this.historyDatas as any)![key] = _data["historyDatas"][key] !== undefined ? _data["historyDatas"][key] : null as any;
                }
            }
            else {
                this.historyDatas = null as any;
            }
            this.lastUpdateTime = _data["lastUpdateTime"] !== undefined ? _data["lastUpdateTime"] : null as any;
            this.totalIn = _data["totalIn"] !== undefined ? _data["totalIn"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): CrowdLandmarkResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CrowdLandmarkResponse>(data, _mappings, CrowdLandmarkResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["lat"] = this.lat !== undefined ? this.lat : null as any;
        data["lng"] = this.lng !== undefined ? this.lng : null as any;
        data["serial"] = this.serial !== undefined ? this.serial : null as any;
        data["area"] = this.area !== undefined ? this.area : null as any;
        data["videoUrl"] = this.videoUrl !== undefined ? this.videoUrl : null as any;
        data["apiUrl"] = this.apiUrl !== undefined ? this.apiUrl : null as any;
        data["status"] = this.status !== undefined ? this.status : null as any;
        data["congestionStatus"] = this.congestionStatus !== undefined ? this.congestionStatus : null as any;
        data["latestRecord"] = this.latestRecord ? this.latestRecord.toJSON() : null as any;
        data["currentPeopleCount"] = this.currentPeopleCount !== undefined ? this.currentPeopleCount : null as any;
        data["crowdDensity"] = this.crowdDensity !== undefined ? this.crowdDensity : null as any;
        if (this.historyDatas) {
            data["historyDatas"] = {};
            for (let key in this.historyDatas) {
                if (this.historyDatas.hasOwnProperty(key))
                    (data["historyDatas"] as any)[key] = this.historyDatas[key] !== undefined ? this.historyDatas[key] : null as any;
            }
        }
        data["lastUpdateTime"] = this.lastUpdateTime !== undefined ? this.lastUpdateTime : null as any;
        data["totalIn"] = this.totalIn !== undefined ? this.totalIn : null as any;
        return data;
    }
}

export interface ICrowdLandmarkResponse {
    id?: number;
    name?: string;
    lat?: number;
    lng?: number;
    serial?: string;
    area?: number;
    videoUrl?: string;
    apiUrl?: string;
    status?: string;
    congestionStatus?: string | null;
    latestRecord?: CrowdRecordInfo | null;
    currentPeopleCount?: number;
    crowdDensity?: number;
    historyDatas?: { [key: string]: number; } | null;
    lastUpdateTime?: string | null;
    totalIn?: number;
}

export class CrowdRecordInfo implements ICrowdRecordInfo {
    time?: number;
    count?: number;
    totalIn?: number;
    deviceSerial?: string;

    constructor(data?: ICrowdRecordInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.time = _data["time"] !== undefined ? _data["time"] : null as any;
            this.count = _data["count"] !== undefined ? _data["count"] : null as any;
            this.totalIn = _data["totalIn"] !== undefined ? _data["totalIn"] : null as any;
            this.deviceSerial = _data["deviceSerial"] !== undefined ? _data["deviceSerial"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): CrowdRecordInfo | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CrowdRecordInfo>(data, _mappings, CrowdRecordInfo);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time !== undefined ? this.time : null as any;
        data["count"] = this.count !== undefined ? this.count : null as any;
        data["totalIn"] = this.totalIn !== undefined ? this.totalIn : null as any;
        data["deviceSerial"] = this.deviceSerial !== undefined ? this.deviceSerial : null as any;
        return data;
    }
}

export interface ICrowdRecordInfo {
    time?: number;
    count?: number;
    totalIn?: number;
    deviceSerial?: string;
}

export class FenceLandmarkResponse implements IFenceLandmarkResponse {
    id?: number;
    name?: string;
    lat?: number;
    lng?: number;
    serial?: string;
    observingTime?: string;
    status?: string;
    latestRecord?: FenceRecordInfo | null;
    lastEvent?: string | null;
    lastEventTime?: number | null;
    historyDatas?: { [key: string]: number; } | null;
    lastUpdateTime?: string | null;
    stationName?: string | null;
    events?: FenceEventInfo[] | null;

    constructor(data?: IFenceLandmarkResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.lat = _data["lat"] !== undefined ? _data["lat"] : null as any;
            this.lng = _data["lng"] !== undefined ? _data["lng"] : null as any;
            this.serial = _data["serial"] !== undefined ? _data["serial"] : null as any;
            this.observingTime = _data["observingTime"] !== undefined ? _data["observingTime"] : null as any;
            this.status = _data["status"] !== undefined ? _data["status"] : null as any;
            this.latestRecord = _data["latestRecord"] ? FenceRecordInfo.fromJS(_data["latestRecord"], _mappings) : null as any;
            this.lastEvent = _data["lastEvent"] !== undefined ? _data["lastEvent"] : null as any;
            this.lastEventTime = _data["lastEventTime"] !== undefined ? _data["lastEventTime"] : null as any;
            if (_data["historyDatas"]) {
                this.historyDatas = {} as any;
                for (let key in _data["historyDatas"]) {
                    if (_data["historyDatas"].hasOwnProperty(key))
                        (this.historyDatas as any)![key] = _data["historyDatas"][key] !== undefined ? _data["historyDatas"][key] : null as any;
                }
            }
            else {
                this.historyDatas = null as any;
            }
            this.lastUpdateTime = _data["lastUpdateTime"] !== undefined ? _data["lastUpdateTime"] : null as any;
            this.stationName = _data["stationName"] !== undefined ? _data["stationName"] : null as any;
            if (Array.isArray(_data["events"])) {
                this.events = [] as any;
                for (let item of _data["events"])
                    this.events!.push(FenceEventInfo.fromJS(item, _mappings));
            }
            else {
                this.events = null as any;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): FenceLandmarkResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FenceLandmarkResponse>(data, _mappings, FenceLandmarkResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["lat"] = this.lat !== undefined ? this.lat : null as any;
        data["lng"] = this.lng !== undefined ? this.lng : null as any;
        data["serial"] = this.serial !== undefined ? this.serial : null as any;
        data["observingTime"] = this.observingTime !== undefined ? this.observingTime : null as any;
        data["status"] = this.status !== undefined ? this.status : null as any;
        data["latestRecord"] = this.latestRecord ? this.latestRecord.toJSON() : null as any;
        data["lastEvent"] = this.lastEvent !== undefined ? this.lastEvent : null as any;
        data["lastEventTime"] = this.lastEventTime !== undefined ? this.lastEventTime : null as any;
        if (this.historyDatas) {
            data["historyDatas"] = {};
            for (let key in this.historyDatas) {
                if (this.historyDatas.hasOwnProperty(key))
                    (data["historyDatas"] as any)[key] = this.historyDatas[key] !== undefined ? this.historyDatas[key] : null as any;
            }
        }
        data["lastUpdateTime"] = this.lastUpdateTime !== undefined ? this.lastUpdateTime : null as any;
        data["stationName"] = this.stationName !== undefined ? this.stationName : null as any;
        if (Array.isArray(this.events)) {
            data["events"] = [];
            for (let item of this.events)
                data["events"].push(item ? item.toJSON() : null as any);
        }
        return data;
    }
}

export interface IFenceLandmarkResponse {
    id?: number;
    name?: string;
    lat?: number;
    lng?: number;
    serial?: string;
    observingTime?: string;
    status?: string;
    latestRecord?: FenceRecordInfo | null;
    lastEvent?: string | null;
    lastEventTime?: number | null;
    historyDatas?: { [key: string]: number; } | null;
    lastUpdateTime?: string | null;
    stationName?: string | null;
    events?: FenceEventInfo[] | null;
}

export class FenceRecordInfo implements IFenceRecordInfo {
    time?: number;
    eventType?: number;
    photo?: string | null;
    deviceSerial?: string;

    constructor(data?: IFenceRecordInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.time = _data["time"] !== undefined ? _data["time"] : null as any;
            this.eventType = _data["eventType"] !== undefined ? _data["eventType"] : null as any;
            this.photo = _data["photo"] !== undefined ? _data["photo"] : null as any;
            this.deviceSerial = _data["deviceSerial"] !== undefined ? _data["deviceSerial"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): FenceRecordInfo | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FenceRecordInfo>(data, _mappings, FenceRecordInfo);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time !== undefined ? this.time : null as any;
        data["eventType"] = this.eventType !== undefined ? this.eventType : null as any;
        data["photo"] = this.photo !== undefined ? this.photo : null as any;
        data["deviceSerial"] = this.deviceSerial !== undefined ? this.deviceSerial : null as any;
        return data;
    }
}

export interface IFenceRecordInfo {
    time?: number;
    eventType?: number;
    photo?: string | null;
    deviceSerial?: string;
}

export class FenceEventInfo implements IFenceEventInfo {
    id?: number;
    eventType?: number;
    time?: string;
    image?: string;

    constructor(data?: IFenceEventInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.eventType = _data["eventType"] !== undefined ? _data["eventType"] : null as any;
            this.time = _data["time"] !== undefined ? _data["time"] : null as any;
            this.image = _data["image"] !== undefined ? _data["image"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): FenceEventInfo | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FenceEventInfo>(data, _mappings, FenceEventInfo);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["eventType"] = this.eventType !== undefined ? this.eventType : null as any;
        data["time"] = this.time !== undefined ? this.time : null as any;
        data["image"] = this.image !== undefined ? this.image : null as any;
        return data;
    }
}

export interface IFenceEventInfo {
    id?: number;
    eventType?: number;
    time?: string;
    image?: string;
}

export class HighResolutionLandmarkResponse implements IHighResolutionLandmarkResponse {
    id?: number;
    name?: string;
    lat?: number;
    lng?: number;
    serial?: string;
    videoUrl?: string;
    status?: string;
    lastUpdateTime?: string | null;

    constructor(data?: IHighResolutionLandmarkResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.lat = _data["lat"] !== undefined ? _data["lat"] : null as any;
            this.lng = _data["lng"] !== undefined ? _data["lng"] : null as any;
            this.serial = _data["serial"] !== undefined ? _data["serial"] : null as any;
            this.videoUrl = _data["videoUrl"] !== undefined ? _data["videoUrl"] : null as any;
            this.status = _data["status"] !== undefined ? _data["status"] : null as any;
            this.lastUpdateTime = _data["lastUpdateTime"] !== undefined ? _data["lastUpdateTime"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): HighResolutionLandmarkResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<HighResolutionLandmarkResponse>(data, _mappings, HighResolutionLandmarkResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["lat"] = this.lat !== undefined ? this.lat : null as any;
        data["lng"] = this.lng !== undefined ? this.lng : null as any;
        data["serial"] = this.serial !== undefined ? this.serial : null as any;
        data["videoUrl"] = this.videoUrl !== undefined ? this.videoUrl : null as any;
        data["status"] = this.status !== undefined ? this.status : null as any;
        data["lastUpdateTime"] = this.lastUpdateTime !== undefined ? this.lastUpdateTime : null as any;
        return data;
    }
}

export interface IHighResolutionLandmarkResponse {
    id?: number;
    name?: string;
    lat?: number;
    lng?: number;
    serial?: string;
    videoUrl?: string;
    status?: string;
    lastUpdateTime?: string | null;
}

export class DeviceOnlineCheckResponse implements IDeviceOnlineCheckResponse {
    success?: boolean;
    message?: string;
    totalDevicesChecked?: number;
    onlineDevices?: number;
    offlineDevices?: number;
    offlineDeviceList?: DeviceOfflineInfo[];
    checkTime?: Date;

    constructor(data?: IDeviceOnlineCheckResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
            this.totalDevicesChecked = _data["totalDevicesChecked"] !== undefined ? _data["totalDevicesChecked"] : null as any;
            this.onlineDevices = _data["onlineDevices"] !== undefined ? _data["onlineDevices"] : null as any;
            this.offlineDevices = _data["offlineDevices"] !== undefined ? _data["offlineDevices"] : null as any;
            if (Array.isArray(_data["offlineDeviceList"])) {
                this.offlineDeviceList = [] as any;
                for (let item of _data["offlineDeviceList"])
                    this.offlineDeviceList!.push(DeviceOfflineInfo.fromJS(item, _mappings));
            }
            else {
                this.offlineDeviceList = null as any;
            }
            this.checkTime = _data["checkTime"] ? new Date(_data["checkTime"].toString()) : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): DeviceOnlineCheckResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<DeviceOnlineCheckResponse>(data, _mappings, DeviceOnlineCheckResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        data["totalDevicesChecked"] = this.totalDevicesChecked !== undefined ? this.totalDevicesChecked : null as any;
        data["onlineDevices"] = this.onlineDevices !== undefined ? this.onlineDevices : null as any;
        data["offlineDevices"] = this.offlineDevices !== undefined ? this.offlineDevices : null as any;
        if (Array.isArray(this.offlineDeviceList)) {
            data["offlineDeviceList"] = [];
            for (let item of this.offlineDeviceList)
                data["offlineDeviceList"].push(item ? item.toJSON() : null as any);
        }
        data["checkTime"] = this.checkTime ? this.checkTime.toISOString() : null as any;
        return data;
    }
}

export interface IDeviceOnlineCheckResponse {
    success?: boolean;
    message?: string;
    totalDevicesChecked?: number;
    onlineDevices?: number;
    offlineDevices?: number;
    offlineDeviceList?: DeviceOfflineInfo[];
    checkTime?: Date;
}

export class DeviceOfflineInfo implements IDeviceOfflineInfo {
    deviceName?: string;
    deviceSerial?: string;
    deviceType?: string;
    lastOnlineTime?: Date;

    constructor(data?: IDeviceOfflineInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.deviceName = _data["deviceName"] !== undefined ? _data["deviceName"] : null as any;
            this.deviceSerial = _data["deviceSerial"] !== undefined ? _data["deviceSerial"] : null as any;
            this.deviceType = _data["deviceType"] !== undefined ? _data["deviceType"] : null as any;
            this.lastOnlineTime = _data["lastOnlineTime"] ? new Date(_data["lastOnlineTime"].toString()) : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): DeviceOfflineInfo | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<DeviceOfflineInfo>(data, _mappings, DeviceOfflineInfo);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceName"] = this.deviceName !== undefined ? this.deviceName : null as any;
        data["deviceSerial"] = this.deviceSerial !== undefined ? this.deviceSerial : null as any;
        data["deviceType"] = this.deviceType !== undefined ? this.deviceType : null as any;
        data["lastOnlineTime"] = this.lastOnlineTime ? this.lastOnlineTime.toISOString() : null as any;
        return data;
    }
}

export interface IDeviceOfflineInfo {
    deviceName?: string;
    deviceSerial?: string;
    deviceType?: string;
    lastOnlineTime?: Date;
}

export class CrowdDataSyncResponse implements ICrowdDataSyncResponse {
    success?: boolean;
    message?: string;
    syncedRecords?: number;
    failedRecords?: number;
    skippedRecords?: number;
    errors?: string[];
    syncTime?: Date;

    constructor(data?: ICrowdDataSyncResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
            this.syncedRecords = _data["syncedRecords"] !== undefined ? _data["syncedRecords"] : null as any;
            this.failedRecords = _data["failedRecords"] !== undefined ? _data["failedRecords"] : null as any;
            this.skippedRecords = _data["skippedRecords"] !== undefined ? _data["skippedRecords"] : null as any;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            else {
                this.errors = null as any;
            }
            this.syncTime = _data["syncTime"] ? new Date(_data["syncTime"].toString()) : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): CrowdDataSyncResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CrowdDataSyncResponse>(data, _mappings, CrowdDataSyncResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        data["syncedRecords"] = this.syncedRecords !== undefined ? this.syncedRecords : null as any;
        data["failedRecords"] = this.failedRecords !== undefined ? this.failedRecords : null as any;
        data["skippedRecords"] = this.skippedRecords !== undefined ? this.skippedRecords : null as any;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["syncTime"] = this.syncTime ? this.syncTime.toISOString() : null as any;
        return data;
    }
}

export interface ICrowdDataSyncResponse {
    success?: boolean;
    message?: string;
    syncedRecords?: number;
    failedRecords?: number;
    skippedRecords?: number;
    errors?: string[];
    syncTime?: Date;
}

export class ParkingDataSyncResponse implements IParkingDataSyncResponse {
    success?: boolean;
    message?: string;
    syncedRecords?: number;
    failedRecords?: number;
    skippedRecords?: number;
    errors?: string[];
    syncTime?: Date;

    constructor(data?: IParkingDataSyncResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
            this.syncedRecords = _data["syncedRecords"] !== undefined ? _data["syncedRecords"] : null as any;
            this.failedRecords = _data["failedRecords"] !== undefined ? _data["failedRecords"] : null as any;
            this.skippedRecords = _data["skippedRecords"] !== undefined ? _data["skippedRecords"] : null as any;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            else {
                this.errors = null as any;
            }
            this.syncTime = _data["syncTime"] ? new Date(_data["syncTime"].toString()) : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): ParkingDataSyncResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ParkingDataSyncResponse>(data, _mappings, ParkingDataSyncResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        data["syncedRecords"] = this.syncedRecords !== undefined ? this.syncedRecords : null as any;
        data["failedRecords"] = this.failedRecords !== undefined ? this.failedRecords : null as any;
        data["skippedRecords"] = this.skippedRecords !== undefined ? this.skippedRecords : null as any;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["syncTime"] = this.syncTime ? this.syncTime.toISOString() : null as any;
        return data;
    }
}

export interface IParkingDataSyncResponse {
    success?: boolean;
    message?: string;
    syncedRecords?: number;
    failedRecords?: number;
    skippedRecords?: number;
    errors?: string[];
    syncTime?: Date;
}

export class TrafficDataSyncResponse implements ITrafficDataSyncResponse {
    success?: boolean;
    message?: string;
    syncedRecords?: number;
    failedRecords?: number;
    skippedRecords?: number;
    errors?: string[];
    syncTime?: Date;

    constructor(data?: ITrafficDataSyncResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
            this.syncedRecords = _data["syncedRecords"] !== undefined ? _data["syncedRecords"] : null as any;
            this.failedRecords = _data["failedRecords"] !== undefined ? _data["failedRecords"] : null as any;
            this.skippedRecords = _data["skippedRecords"] !== undefined ? _data["skippedRecords"] : null as any;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            else {
                this.errors = null as any;
            }
            this.syncTime = _data["syncTime"] ? new Date(_data["syncTime"].toString()) : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): TrafficDataSyncResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TrafficDataSyncResponse>(data, _mappings, TrafficDataSyncResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        data["syncedRecords"] = this.syncedRecords !== undefined ? this.syncedRecords : null as any;
        data["failedRecords"] = this.failedRecords !== undefined ? this.failedRecords : null as any;
        data["skippedRecords"] = this.skippedRecords !== undefined ? this.skippedRecords : null as any;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["syncTime"] = this.syncTime ? this.syncTime.toISOString() : null as any;
        return data;
    }
}

export interface ITrafficDataSyncResponse {
    success?: boolean;
    message?: string;
    syncedRecords?: number;
    failedRecords?: number;
    skippedRecords?: number;
    errors?: string[];
    syncTime?: Date;
}

export class DatabaseBackupResponse implements IDatabaseBackupResponse {
    success?: boolean;
    message?: string;
    backupFilePath?: string;
    backupFileSize?: number;
    backupDuration?: string;
    backupTime?: Date;

    constructor(data?: IDatabaseBackupResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
            this.backupFilePath = _data["backupFilePath"] !== undefined ? _data["backupFilePath"] : null as any;
            this.backupFileSize = _data["backupFileSize"] !== undefined ? _data["backupFileSize"] : null as any;
            this.backupDuration = _data["backupDuration"] !== undefined ? _data["backupDuration"] : null as any;
            this.backupTime = _data["backupTime"] ? new Date(_data["backupTime"].toString()) : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): DatabaseBackupResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<DatabaseBackupResponse>(data, _mappings, DatabaseBackupResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        data["backupFilePath"] = this.backupFilePath !== undefined ? this.backupFilePath : null as any;
        data["backupFileSize"] = this.backupFileSize !== undefined ? this.backupFileSize : null as any;
        data["backupDuration"] = this.backupDuration !== undefined ? this.backupDuration : null as any;
        data["backupTime"] = this.backupTime ? this.backupTime.toISOString() : null as any;
        return data;
    }
}

export interface IDatabaseBackupResponse {
    success?: boolean;
    message?: string;
    backupFilePath?: string;
    backupFileSize?: number;
    backupDuration?: string;
    backupTime?: Date;
}

export class LogBackupResponse implements ILogBackupResponse {
    success?: boolean;
    message?: string;
    backedUpFiles?: number;
    totalBackupSize?: number;
    backupLocation?: string;
    backupTime?: Date;

    constructor(data?: ILogBackupResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
            this.backedUpFiles = _data["backedUpFiles"] !== undefined ? _data["backedUpFiles"] : null as any;
            this.totalBackupSize = _data["totalBackupSize"] !== undefined ? _data["totalBackupSize"] : null as any;
            this.backupLocation = _data["backupLocation"] !== undefined ? _data["backupLocation"] : null as any;
            this.backupTime = _data["backupTime"] ? new Date(_data["backupTime"].toString()) : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): LogBackupResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<LogBackupResponse>(data, _mappings, LogBackupResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        data["backedUpFiles"] = this.backedUpFiles !== undefined ? this.backedUpFiles : null as any;
        data["totalBackupSize"] = this.totalBackupSize !== undefined ? this.totalBackupSize : null as any;
        data["backupLocation"] = this.backupLocation !== undefined ? this.backupLocation : null as any;
        data["backupTime"] = this.backupTime ? this.backupTime.toISOString() : null as any;
        return data;
    }
}

export interface ILogBackupResponse {
    success?: boolean;
    message?: string;
    backedUpFiles?: number;
    totalBackupSize?: number;
    backupLocation?: string;
    backupTime?: Date;
}

export class AuditLogCleanupResponse implements IAuditLogCleanupResponse {
    success?: boolean;
    message?: string;
    cleanedFiles?: number;
    freedSpace?: number;
    retentionDays?: number;
    cleanupTime?: Date;

    constructor(data?: IAuditLogCleanupResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
            this.cleanedFiles = _data["cleanedFiles"] !== undefined ? _data["cleanedFiles"] : null as any;
            this.freedSpace = _data["freedSpace"] !== undefined ? _data["freedSpace"] : null as any;
            this.retentionDays = _data["retentionDays"] !== undefined ? _data["retentionDays"] : null as any;
            this.cleanupTime = _data["cleanupTime"] ? new Date(_data["cleanupTime"].toString()) : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): AuditLogCleanupResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<AuditLogCleanupResponse>(data, _mappings, AuditLogCleanupResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        data["cleanedFiles"] = this.cleanedFiles !== undefined ? this.cleanedFiles : null as any;
        data["freedSpace"] = this.freedSpace !== undefined ? this.freedSpace : null as any;
        data["retentionDays"] = this.retentionDays !== undefined ? this.retentionDays : null as any;
        data["cleanupTime"] = this.cleanupTime ? this.cleanupTime.toISOString() : null as any;
        return data;
    }
}

export interface IAuditLogCleanupResponse {
    success?: boolean;
    message?: string;
    cleanedFiles?: number;
    freedSpace?: number;
    retentionDays?: number;
    cleanupTime?: Date;
}

export class SystemHealthResponse implements ISystemHealthResponse {
    isHealthy?: boolean;
    taskStatuses?: ScheduledTaskStatus[];
    systemInfo?: { [key: string]: any; };
    checkTime?: Date;

    constructor(data?: ISystemHealthResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.isHealthy = _data["isHealthy"] !== undefined ? _data["isHealthy"] : null as any;
            if (Array.isArray(_data["taskStatuses"])) {
                this.taskStatuses = [] as any;
                for (let item of _data["taskStatuses"])
                    this.taskStatuses!.push(ScheduledTaskStatus.fromJS(item, _mappings));
            }
            else {
                this.taskStatuses = null as any;
            }
            if (_data["systemInfo"]) {
                this.systemInfo = {} as any;
                for (let key in _data["systemInfo"]) {
                    if (_data["systemInfo"].hasOwnProperty(key))
                        (this.systemInfo as any)![key] = _data["systemInfo"][key] !== undefined ? _data["systemInfo"][key] : null as any;
                }
            }
            else {
                this.systemInfo = null as any;
            }
            this.checkTime = _data["checkTime"] ? new Date(_data["checkTime"].toString()) : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): SystemHealthResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SystemHealthResponse>(data, _mappings, SystemHealthResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isHealthy"] = this.isHealthy !== undefined ? this.isHealthy : null as any;
        if (Array.isArray(this.taskStatuses)) {
            data["taskStatuses"] = [];
            for (let item of this.taskStatuses)
                data["taskStatuses"].push(item ? item.toJSON() : null as any);
        }
        if (this.systemInfo) {
            data["systemInfo"] = {};
            for (let key in this.systemInfo) {
                if (this.systemInfo.hasOwnProperty(key))
                    (data["systemInfo"] as any)[key] = this.systemInfo[key] !== undefined ? this.systemInfo[key] : null as any;
            }
        }
        data["checkTime"] = this.checkTime ? this.checkTime.toISOString() : null as any;
        return data;
    }
}

export interface ISystemHealthResponse {
    isHealthy?: boolean;
    taskStatuses?: ScheduledTaskStatus[];
    systemInfo?: { [key: string]: any; };
    checkTime?: Date;
}

export class ScheduledTaskStatus implements IScheduledTaskStatus {
    taskName?: string;
    lastRunTime?: Date;
    nextRunTime?: Date | null;
    isRunning?: boolean;
    status?: string;
    lastError?: string | null;
    executionTime?: string;

    constructor(data?: IScheduledTaskStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.taskName = _data["taskName"] !== undefined ? _data["taskName"] : null as any;
            this.lastRunTime = _data["lastRunTime"] ? new Date(_data["lastRunTime"].toString()) : null as any;
            this.nextRunTime = _data["nextRunTime"] ? new Date(_data["nextRunTime"].toString()) : null as any;
            this.isRunning = _data["isRunning"] !== undefined ? _data["isRunning"] : null as any;
            this.status = _data["status"] !== undefined ? _data["status"] : null as any;
            this.lastError = _data["lastError"] !== undefined ? _data["lastError"] : null as any;
            this.executionTime = _data["executionTime"] !== undefined ? _data["executionTime"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): ScheduledTaskStatus | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ScheduledTaskStatus>(data, _mappings, ScheduledTaskStatus);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskName"] = this.taskName !== undefined ? this.taskName : null as any;
        data["lastRunTime"] = this.lastRunTime ? this.lastRunTime.toISOString() : null as any;
        data["nextRunTime"] = this.nextRunTime ? this.nextRunTime.toISOString() : null as any;
        data["isRunning"] = this.isRunning !== undefined ? this.isRunning : null as any;
        data["status"] = this.status !== undefined ? this.status : null as any;
        data["lastError"] = this.lastError !== undefined ? this.lastError : null as any;
        data["executionTime"] = this.executionTime !== undefined ? this.executionTime : null as any;
        return data;
    }
}

export interface IScheduledTaskStatus {
    taskName?: string;
    lastRunTime?: Date;
    nextRunTime?: Date | null;
    isRunning?: boolean;
    status?: string;
    lastError?: string | null;
    executionTime?: string;
}

export class StationResponse implements IStationResponse {
    id?: number;
    name?: string;
    lat?: number;
    lng?: number;
    lineToken?: string | null;
    enableNotify?: boolean;
    cvpLocations?: string;
    crowdDevices?: DeviceResponse[];
    parkingDevices?: DeviceResponse[];
    trafficDevices?: DeviceResponse[];
    fenceDevices?: DeviceResponse[];
    highResolutionDevices?: DeviceResponse[];

    constructor(data?: IStationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.lat = _data["lat"] !== undefined ? _data["lat"] : null as any;
            this.lng = _data["lng"] !== undefined ? _data["lng"] : null as any;
            this.lineToken = _data["lineToken"] !== undefined ? _data["lineToken"] : null as any;
            this.enableNotify = _data["enableNotify"] !== undefined ? _data["enableNotify"] : null as any;
            this.cvpLocations = _data["cvpLocations"] !== undefined ? _data["cvpLocations"] : null as any;
            if (Array.isArray(_data["crowdDevices"])) {
                this.crowdDevices = [] as any;
                for (let item of _data["crowdDevices"])
                    this.crowdDevices!.push(DeviceResponse.fromJS(item, _mappings));
            }
            else {
                this.crowdDevices = null as any;
            }
            if (Array.isArray(_data["parkingDevices"])) {
                this.parkingDevices = [] as any;
                for (let item of _data["parkingDevices"])
                    this.parkingDevices!.push(DeviceResponse.fromJS(item, _mappings));
            }
            else {
                this.parkingDevices = null as any;
            }
            if (Array.isArray(_data["trafficDevices"])) {
                this.trafficDevices = [] as any;
                for (let item of _data["trafficDevices"])
                    this.trafficDevices!.push(DeviceResponse.fromJS(item, _mappings));
            }
            else {
                this.trafficDevices = null as any;
            }
            if (Array.isArray(_data["fenceDevices"])) {
                this.fenceDevices = [] as any;
                for (let item of _data["fenceDevices"])
                    this.fenceDevices!.push(DeviceResponse.fromJS(item, _mappings));
            }
            else {
                this.fenceDevices = null as any;
            }
            if (Array.isArray(_data["highResolutionDevices"])) {
                this.highResolutionDevices = [] as any;
                for (let item of _data["highResolutionDevices"])
                    this.highResolutionDevices!.push(DeviceResponse.fromJS(item, _mappings));
            }
            else {
                this.highResolutionDevices = null as any;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): StationResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<StationResponse>(data, _mappings, StationResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["lat"] = this.lat !== undefined ? this.lat : null as any;
        data["lng"] = this.lng !== undefined ? this.lng : null as any;
        data["lineToken"] = this.lineToken !== undefined ? this.lineToken : null as any;
        data["enableNotify"] = this.enableNotify !== undefined ? this.enableNotify : null as any;
        data["cvpLocations"] = this.cvpLocations !== undefined ? this.cvpLocations : null as any;
        if (Array.isArray(this.crowdDevices)) {
            data["crowdDevices"] = [];
            for (let item of this.crowdDevices)
                data["crowdDevices"].push(item ? item.toJSON() : null as any);
        }
        if (Array.isArray(this.parkingDevices)) {
            data["parkingDevices"] = [];
            for (let item of this.parkingDevices)
                data["parkingDevices"].push(item ? item.toJSON() : null as any);
        }
        if (Array.isArray(this.trafficDevices)) {
            data["trafficDevices"] = [];
            for (let item of this.trafficDevices)
                data["trafficDevices"].push(item ? item.toJSON() : null as any);
        }
        if (Array.isArray(this.fenceDevices)) {
            data["fenceDevices"] = [];
            for (let item of this.fenceDevices)
                data["fenceDevices"].push(item ? item.toJSON() : null as any);
        }
        if (Array.isArray(this.highResolutionDevices)) {
            data["highResolutionDevices"] = [];
            for (let item of this.highResolutionDevices)
                data["highResolutionDevices"].push(item ? item.toJSON() : null as any);
        }
        return data;
    }
}

export interface IStationResponse {
    id?: number;
    name?: string;
    lat?: number;
    lng?: number;
    lineToken?: string | null;
    enableNotify?: boolean;
    cvpLocations?: string;
    crowdDevices?: DeviceResponse[];
    parkingDevices?: DeviceResponse[];
    trafficDevices?: DeviceResponse[];
    fenceDevices?: DeviceResponse[];
    highResolutionDevices?: DeviceResponse[];
}

export class DeviceResponse implements IDeviceResponse {
    id?: number;
    stationID?: number;
    name?: string;
    serial?: string;
    lat?: number;
    lng?: number;
    videoUrl?: string | null;
    apiUrl?: string | null;
    area?: number;
    numberOfParking?: number;
    city?: string | null;
    eTag_number?: string | null;
    speedLimit?: number;
    observingTime?: string | null;

    constructor(data?: IDeviceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.stationID = _data["stationID"] !== undefined ? _data["stationID"] : null as any;
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.serial = _data["serial"] !== undefined ? _data["serial"] : null as any;
            this.lat = _data["lat"] !== undefined ? _data["lat"] : null as any;
            this.lng = _data["lng"] !== undefined ? _data["lng"] : null as any;
            this.videoUrl = _data["videoUrl"] !== undefined ? _data["videoUrl"] : null as any;
            this.apiUrl = _data["apiUrl"] !== undefined ? _data["apiUrl"] : null as any;
            this.area = _data["area"] !== undefined ? _data["area"] : null as any;
            this.numberOfParking = _data["numberOfParking"] !== undefined ? _data["numberOfParking"] : null as any;
            this.city = _data["city"] !== undefined ? _data["city"] : null as any;
            this.eTag_number = _data["eTag_number"] !== undefined ? _data["eTag_number"] : null as any;
            this.speedLimit = _data["speedLimit"] !== undefined ? _data["speedLimit"] : null as any;
            this.observingTime = _data["observingTime"] !== undefined ? _data["observingTime"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): DeviceResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<DeviceResponse>(data, _mappings, DeviceResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["stationID"] = this.stationID !== undefined ? this.stationID : null as any;
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["serial"] = this.serial !== undefined ? this.serial : null as any;
        data["lat"] = this.lat !== undefined ? this.lat : null as any;
        data["lng"] = this.lng !== undefined ? this.lng : null as any;
        data["videoUrl"] = this.videoUrl !== undefined ? this.videoUrl : null as any;
        data["apiUrl"] = this.apiUrl !== undefined ? this.apiUrl : null as any;
        data["area"] = this.area !== undefined ? this.area : null as any;
        data["numberOfParking"] = this.numberOfParking !== undefined ? this.numberOfParking : null as any;
        data["city"] = this.city !== undefined ? this.city : null as any;
        data["eTag_number"] = this.eTag_number !== undefined ? this.eTag_number : null as any;
        data["speedLimit"] = this.speedLimit !== undefined ? this.speedLimit : null as any;
        data["observingTime"] = this.observingTime !== undefined ? this.observingTime : null as any;
        return data;
    }
}

export interface IDeviceResponse {
    id?: number;
    stationID?: number;
    name?: string;
    serial?: string;
    lat?: number;
    lng?: number;
    videoUrl?: string | null;
    apiUrl?: string | null;
    area?: number;
    numberOfParking?: number;
    city?: string | null;
    eTag_number?: string | null;
    speedLimit?: number;
    observingTime?: string | null;
}

export class CreateStationRequest implements ICreateStationRequest {
    name?: string;
    lat?: number;
    lng?: number;
    lineToken?: string | null;
    enableNotify?: boolean;
    cvpLocations?: string | null;

    constructor(data?: ICreateStationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.lat = _data["lat"] !== undefined ? _data["lat"] : null as any;
            this.lng = _data["lng"] !== undefined ? _data["lng"] : null as any;
            this.lineToken = _data["lineToken"] !== undefined ? _data["lineToken"] : null as any;
            this.enableNotify = _data["enableNotify"] !== undefined ? _data["enableNotify"] : null as any;
            this.cvpLocations = _data["cvpLocations"] !== undefined ? _data["cvpLocations"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): CreateStationRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CreateStationRequest>(data, _mappings, CreateStationRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["lat"] = this.lat !== undefined ? this.lat : null as any;
        data["lng"] = this.lng !== undefined ? this.lng : null as any;
        data["lineToken"] = this.lineToken !== undefined ? this.lineToken : null as any;
        data["enableNotify"] = this.enableNotify !== undefined ? this.enableNotify : null as any;
        data["cvpLocations"] = this.cvpLocations !== undefined ? this.cvpLocations : null as any;
        return data;
    }
}

export interface ICreateStationRequest {
    name?: string;
    lat?: number;
    lng?: number;
    lineToken?: string | null;
    enableNotify?: boolean;
    cvpLocations?: string | null;
}

export class UpdateStationRequest implements IUpdateStationRequest {
    name?: string;
    lat?: number;
    lng?: number;
    lineToken?: string | null;
    enableNotify?: boolean;
    cvpLocations?: string | null;

    constructor(data?: IUpdateStationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.lat = _data["lat"] !== undefined ? _data["lat"] : null as any;
            this.lng = _data["lng"] !== undefined ? _data["lng"] : null as any;
            this.lineToken = _data["lineToken"] !== undefined ? _data["lineToken"] : null as any;
            this.enableNotify = _data["enableNotify"] !== undefined ? _data["enableNotify"] : null as any;
            this.cvpLocations = _data["cvpLocations"] !== undefined ? _data["cvpLocations"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): UpdateStationRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<UpdateStationRequest>(data, _mappings, UpdateStationRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["lat"] = this.lat !== undefined ? this.lat : null as any;
        data["lng"] = this.lng !== undefined ? this.lng : null as any;
        data["lineToken"] = this.lineToken !== undefined ? this.lineToken : null as any;
        data["enableNotify"] = this.enableNotify !== undefined ? this.enableNotify : null as any;
        data["cvpLocations"] = this.cvpLocations !== undefined ? this.cvpLocations : null as any;
        return data;
    }
}

export interface IUpdateStationRequest {
    name?: string;
    lat?: number;
    lng?: number;
    lineToken?: string | null;
    enableNotify?: boolean;
    cvpLocations?: string | null;
}

export class SystemSettingResponse implements ISystemSettingResponse {
    message?: string;

    constructor(data?: ISystemSettingResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): SystemSettingResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SystemSettingResponse>(data, _mappings, SystemSettingResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message !== undefined ? this.message : null as any;
        return data;
    }
}

export interface ISystemSettingResponse {
    message?: string;
}

export class UpdateSystemSettingRequest implements IUpdateSystemSettingRequest {
    settingName?: string;
    settingValue?: string;

    constructor(data?: IUpdateSystemSettingRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.settingName = _data["settingName"] !== undefined ? _data["settingName"] : null as any;
            this.settingValue = _data["settingValue"] !== undefined ? _data["settingValue"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): UpdateSystemSettingRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<UpdateSystemSettingRequest>(data, _mappings, UpdateSystemSettingRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settingName"] = this.settingName !== undefined ? this.settingName : null as any;
        data["settingValue"] = this.settingValue !== undefined ? this.settingValue : null as any;
        return data;
    }
}

export interface IUpdateSystemSettingRequest {
    settingName?: string;
    settingValue?: string;
}

export class CreateFenceRecordResponse implements ICreateFenceRecordResponse {
    message?: string;

    constructor(data?: ICreateFenceRecordResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): CreateFenceRecordResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CreateFenceRecordResponse>(data, _mappings, CreateFenceRecordResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message !== undefined ? this.message : null as any;
        return data;
    }
}

export interface ICreateFenceRecordResponse {
    message?: string;
}

export class CreateFenceRecordRequest implements ICreateFenceRecordRequest {
    camera_id?: string;
    event_type?: number;
    time?: string;
    snapshot?: string | null;

    constructor(data?: ICreateFenceRecordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.camera_id = _data["camera_id"] !== undefined ? _data["camera_id"] : null as any;
            this.event_type = _data["event_type"] !== undefined ? _data["event_type"] : null as any;
            this.time = _data["time"] !== undefined ? _data["time"] : null as any;
            this.snapshot = _data["snapshot"] !== undefined ? _data["snapshot"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): CreateFenceRecordRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CreateFenceRecordRequest>(data, _mappings, CreateFenceRecordRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["camera_id"] = this.camera_id !== undefined ? this.camera_id : null as any;
        data["event_type"] = this.event_type !== undefined ? this.event_type : null as any;
        data["time"] = this.time !== undefined ? this.time : null as any;
        data["snapshot"] = this.snapshot !== undefined ? this.snapshot : null as any;
        return data;
    }
}

export interface ICreateFenceRecordRequest {
    camera_id?: string;
    event_type?: number;
    time?: string;
    snapshot?: string | null;
}

export class UpdateFenceHeartbeatResponse implements IUpdateFenceHeartbeatResponse {
    message?: string;

    constructor(data?: IUpdateFenceHeartbeatResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): UpdateFenceHeartbeatResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<UpdateFenceHeartbeatResponse>(data, _mappings, UpdateFenceHeartbeatResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message !== undefined ? this.message : null as any;
        return data;
    }
}

export interface IUpdateFenceHeartbeatResponse {
    message?: string;
}

export class UpdateFenceHeartbeatRequest implements IUpdateFenceHeartbeatRequest {
    camera_id?: string;
    time?: string;

    constructor(data?: IUpdateFenceHeartbeatRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.camera_id = _data["camera_id"] !== undefined ? _data["camera_id"] : null as any;
            this.time = _data["time"] !== undefined ? _data["time"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): UpdateFenceHeartbeatRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<UpdateFenceHeartbeatRequest>(data, _mappings, UpdateFenceHeartbeatRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["camera_id"] = this.camera_id !== undefined ? this.camera_id : null as any;
        data["time"] = this.time !== undefined ? this.time : null as any;
        return data;
    }
}

export interface IUpdateFenceHeartbeatRequest {
    camera_id?: string;
    time?: string;
}

export class CreateCrowdRecordResponse implements ICreateCrowdRecordResponse {
    message?: string;

    constructor(data?: ICreateCrowdRecordResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): CreateCrowdRecordResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CreateCrowdRecordResponse>(data, _mappings, CreateCrowdRecordResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message !== undefined ? this.message : null as any;
        return data;
    }
}

export interface ICreateCrowdRecordResponse {
    message?: string;
}

export class CreateCrowdRecordRequest implements ICreateCrowdRecordRequest {
    camera_id?: string;
    count?: number;
    time?: string;
    total_in?: number;
    total_out?: number;

    constructor(data?: ICreateCrowdRecordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.camera_id = _data["camera_id"] !== undefined ? _data["camera_id"] : null as any;
            this.count = _data["count"] !== undefined ? _data["count"] : null as any;
            this.time = _data["time"] !== undefined ? _data["time"] : null as any;
            this.total_in = _data["total_in"] !== undefined ? _data["total_in"] : null as any;
            this.total_out = _data["total_out"] !== undefined ? _data["total_out"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): CreateCrowdRecordRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CreateCrowdRecordRequest>(data, _mappings, CreateCrowdRecordRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["camera_id"] = this.camera_id !== undefined ? this.camera_id : null as any;
        data["count"] = this.count !== undefined ? this.count : null as any;
        data["time"] = this.time !== undefined ? this.time : null as any;
        data["total_in"] = this.total_in !== undefined ? this.total_in : null as any;
        data["total_out"] = this.total_out !== undefined ? this.total_out : null as any;
        return data;
    }
}

export interface ICreateCrowdRecordRequest {
    camera_id?: string;
    count?: number;
    time?: string;
    total_in?: number;
    total_out?: number;
}

export class CreateParkingRecordResponse implements ICreateParkingRecordResponse {
    message?: string;

    constructor(data?: ICreateParkingRecordResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): CreateParkingRecordResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CreateParkingRecordResponse>(data, _mappings, CreateParkingRecordResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message !== undefined ? this.message : null as any;
        return data;
    }
}

export interface ICreateParkingRecordResponse {
    message?: string;
}

export class CreateParkingRecordRequest implements ICreateParkingRecordRequest {
    siteId?: string;
    usageCount?: number;
    computeTime?: string;
    carType?: string;
    rentCount?: number;

    constructor(data?: ICreateParkingRecordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.siteId = _data["SiteId"] !== undefined ? _data["SiteId"] : null as any;
            this.usageCount = _data["UsageCount"] !== undefined ? _data["UsageCount"] : null as any;
            this.computeTime = _data["ComputeTime"] !== undefined ? _data["ComputeTime"] : null as any;
            this.carType = _data["CarType"] !== undefined ? _data["CarType"] : null as any;
            this.rentCount = _data["RentCount"] !== undefined ? _data["RentCount"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): CreateParkingRecordRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CreateParkingRecordRequest>(data, _mappings, CreateParkingRecordRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SiteId"] = this.siteId !== undefined ? this.siteId : null as any;
        data["UsageCount"] = this.usageCount !== undefined ? this.usageCount : null as any;
        data["ComputeTime"] = this.computeTime !== undefined ? this.computeTime : null as any;
        data["CarType"] = this.carType !== undefined ? this.carType : null as any;
        data["RentCount"] = this.rentCount !== undefined ? this.rentCount : null as any;
        return data;
    }
}

export interface ICreateParkingRecordRequest {
    siteId?: string;
    usageCount?: number;
    computeTime?: string;
    carType?: string;
    rentCount?: number;
}

export class ThirdPartyStationInfo implements IThirdPartyStationInfo {
    id?: number;
    name?: string;
    lat?: number;
    lng?: number;

    constructor(data?: IThirdPartyStationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.lat = _data["lat"] !== undefined ? _data["lat"] : null as any;
            this.lng = _data["lng"] !== undefined ? _data["lng"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): ThirdPartyStationInfo | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ThirdPartyStationInfo>(data, _mappings, ThirdPartyStationInfo);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["lat"] = this.lat !== undefined ? this.lat : null as any;
        data["lng"] = this.lng !== undefined ? this.lng : null as any;
        return data;
    }
}

export interface IThirdPartyStationInfo {
    id?: number;
    name?: string;
    lat?: number;
    lng?: number;
}

export class ThirdPartyFenceDeviceInfo implements IThirdPartyFenceDeviceInfo {
    id?: number;
    name?: string;
    station_id?: number;

    constructor(data?: IThirdPartyFenceDeviceInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.station_id = _data["station_id"] !== undefined ? _data["station_id"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): ThirdPartyFenceDeviceInfo | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ThirdPartyFenceDeviceInfo>(data, _mappings, ThirdPartyFenceDeviceInfo);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["station_id"] = this.station_id !== undefined ? this.station_id : null as any;
        return data;
    }
}

export interface IThirdPartyFenceDeviceInfo {
    id?: number;
    name?: string;
    station_id?: number;
}

export class ThirdPartyCrowdDeviceInfo implements IThirdPartyCrowdDeviceInfo {
    id?: string;
    name?: string;
    station_id?: number;
    lat?: number;
    lng?: number;
    area?: number | null;
    count?: number | null;
    time?: string | null;

    constructor(data?: IThirdPartyCrowdDeviceInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.station_id = _data["station_id"] !== undefined ? _data["station_id"] : null as any;
            this.lat = _data["lat"] !== undefined ? _data["lat"] : null as any;
            this.lng = _data["lng"] !== undefined ? _data["lng"] : null as any;
            this.area = _data["area"] !== undefined ? _data["area"] : null as any;
            this.count = _data["count"] !== undefined ? _data["count"] : null as any;
            this.time = _data["time"] !== undefined ? _data["time"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): ThirdPartyCrowdDeviceInfo | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ThirdPartyCrowdDeviceInfo>(data, _mappings, ThirdPartyCrowdDeviceInfo);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["station_id"] = this.station_id !== undefined ? this.station_id : null as any;
        data["lat"] = this.lat !== undefined ? this.lat : null as any;
        data["lng"] = this.lng !== undefined ? this.lng : null as any;
        data["area"] = this.area !== undefined ? this.area : null as any;
        data["count"] = this.count !== undefined ? this.count : null as any;
        data["time"] = this.time !== undefined ? this.time : null as any;
        return data;
    }
}

export interface IThirdPartyCrowdDeviceInfo {
    id?: string;
    name?: string;
    station_id?: number;
    lat?: number;
    lng?: number;
    area?: number | null;
    count?: number | null;
    time?: string | null;
}

export class ThirdPartyParkingDeviceInfo implements IThirdPartyParkingDeviceInfo {
    id?: string;
    name?: string;
    lat?: number;
    lng?: number;
    station_id?: number;
    number_of_spaces?: number;
    parked_num?: number;
    total_in?: number;
    total_out?: number;
    time?: string | null;

    constructor(data?: IThirdPartyParkingDeviceInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.lat = _data["lat"] !== undefined ? _data["lat"] : null as any;
            this.lng = _data["lng"] !== undefined ? _data["lng"] : null as any;
            this.station_id = _data["station_id"] !== undefined ? _data["station_id"] : null as any;
            this.number_of_spaces = _data["number_of_spaces"] !== undefined ? _data["number_of_spaces"] : null as any;
            this.parked_num = _data["parked_num"] !== undefined ? _data["parked_num"] : null as any;
            this.total_in = _data["total_in"] !== undefined ? _data["total_in"] : null as any;
            this.total_out = _data["total_out"] !== undefined ? _data["total_out"] : null as any;
            this.time = _data["time"] !== undefined ? _data["time"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): ThirdPartyParkingDeviceInfo | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ThirdPartyParkingDeviceInfo>(data, _mappings, ThirdPartyParkingDeviceInfo);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["lat"] = this.lat !== undefined ? this.lat : null as any;
        data["lng"] = this.lng !== undefined ? this.lng : null as any;
        data["station_id"] = this.station_id !== undefined ? this.station_id : null as any;
        data["number_of_spaces"] = this.number_of_spaces !== undefined ? this.number_of_spaces : null as any;
        data["parked_num"] = this.parked_num !== undefined ? this.parked_num : null as any;
        data["total_in"] = this.total_in !== undefined ? this.total_in : null as any;
        data["total_out"] = this.total_out !== undefined ? this.total_out : null as any;
        data["time"] = this.time !== undefined ? this.time : null as any;
        return data;
    }
}

export interface IThirdPartyParkingDeviceInfo {
    id?: string;
    name?: string;
    lat?: number;
    lng?: number;
    station_id?: number;
    number_of_spaces?: number;
    parked_num?: number;
    total_in?: number;
    total_out?: number;
    time?: string | null;
}

export class ThirdPartyTrafficDeviceInfo implements IThirdPartyTrafficDeviceInfo {
    id?: string;
    name?: string;
    lat?: number;
    lng?: number;
    station_id?: number;
    etag_pair_id?: string | null;
    speed_limit?: number | null;
    travel_time?: number | null;
    space_mean_speed?: number | null;
    time?: string | null;

    constructor(data?: IThirdPartyTrafficDeviceInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.lat = _data["lat"] !== undefined ? _data["lat"] : null as any;
            this.lng = _data["lng"] !== undefined ? _data["lng"] : null as any;
            this.station_id = _data["station_id"] !== undefined ? _data["station_id"] : null as any;
            this.etag_pair_id = _data["etag_pair_id"] !== undefined ? _data["etag_pair_id"] : null as any;
            this.speed_limit = _data["speed_limit"] !== undefined ? _data["speed_limit"] : null as any;
            this.travel_time = _data["travel_time"] !== undefined ? _data["travel_time"] : null as any;
            this.space_mean_speed = _data["space_mean_speed"] !== undefined ? _data["space_mean_speed"] : null as any;
            this.time = _data["time"] !== undefined ? _data["time"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): ThirdPartyTrafficDeviceInfo | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ThirdPartyTrafficDeviceInfo>(data, _mappings, ThirdPartyTrafficDeviceInfo);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["lat"] = this.lat !== undefined ? this.lat : null as any;
        data["lng"] = this.lng !== undefined ? this.lng : null as any;
        data["station_id"] = this.station_id !== undefined ? this.station_id : null as any;
        data["etag_pair_id"] = this.etag_pair_id !== undefined ? this.etag_pair_id : null as any;
        data["speed_limit"] = this.speed_limit !== undefined ? this.speed_limit : null as any;
        data["travel_time"] = this.travel_time !== undefined ? this.travel_time : null as any;
        data["space_mean_speed"] = this.space_mean_speed !== undefined ? this.space_mean_speed : null as any;
        data["time"] = this.time !== undefined ? this.time : null as any;
        return data;
    }
}

export interface IThirdPartyTrafficDeviceInfo {
    id?: string;
    name?: string;
    lat?: number;
    lng?: number;
    station_id?: number;
    etag_pair_id?: string | null;
    speed_limit?: number | null;
    travel_time?: number | null;
    space_mean_speed?: number | null;
    time?: string | null;
}

export class FenceDeviceConfigDto implements IFenceDeviceConfigDto {
    serial?: string;
    name?: string;
    video_url?: string | null;
    observing_time_start?: string | null;
    observing_time_end?: string | null;
    zones?: FenceZoneDto[];
    camera_config?: any | null;

    constructor(data?: IFenceDeviceConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.serial = _data["serial"] !== undefined ? _data["serial"] : null as any;
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.video_url = _data["video_url"] !== undefined ? _data["video_url"] : null as any;
            this.observing_time_start = _data["observing_time_start"] !== undefined ? _data["observing_time_start"] : null as any;
            this.observing_time_end = _data["observing_time_end"] !== undefined ? _data["observing_time_end"] : null as any;
            if (Array.isArray(_data["zones"])) {
                this.zones = [] as any;
                for (let item of _data["zones"])
                    this.zones!.push(FenceZoneDto.fromJS(item, _mappings));
            }
            else {
                this.zones = null as any;
            }
            this.camera_config = _data["camera_config"] !== undefined ? _data["camera_config"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): FenceDeviceConfigDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FenceDeviceConfigDto>(data, _mappings, FenceDeviceConfigDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serial"] = this.serial !== undefined ? this.serial : null as any;
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["video_url"] = this.video_url !== undefined ? this.video_url : null as any;
        data["observing_time_start"] = this.observing_time_start !== undefined ? this.observing_time_start : null as any;
        data["observing_time_end"] = this.observing_time_end !== undefined ? this.observing_time_end : null as any;
        if (Array.isArray(this.zones)) {
            data["zones"] = [];
            for (let item of this.zones)
                data["zones"].push(item ? item.toJSON() : null as any);
        }
        data["camera_config"] = this.camera_config !== undefined ? this.camera_config : null as any;
        return data;
    }
}

export interface IFenceDeviceConfigDto {
    serial?: string;
    name?: string;
    video_url?: string | null;
    observing_time_start?: string | null;
    observing_time_end?: string | null;
    zones?: FenceZoneDto[];
    camera_config?: any | null;
}

export class FenceZoneDto implements IFenceZoneDto {
    name?: string;
    points?: FencePointDto[];
    cooldown?: number;
    enabled?: boolean;
    zoneType?: string;

    constructor(data?: IFenceZoneDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.name = _data["Name"] !== undefined ? _data["Name"] : null as any;
            if (Array.isArray(_data["Points"])) {
                this.points = [] as any;
                for (let item of _data["Points"])
                    this.points!.push(FencePointDto.fromJS(item, _mappings));
            }
            else {
                this.points = null as any;
            }
            this.cooldown = _data["Cooldown"] !== undefined ? _data["Cooldown"] : null as any;
            this.enabled = _data["Enabled"] !== undefined ? _data["Enabled"] : null as any;
            this.zoneType = _data["ZoneType"] !== undefined ? _data["ZoneType"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): FenceZoneDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FenceZoneDto>(data, _mappings, FenceZoneDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name !== undefined ? this.name : null as any;
        if (Array.isArray(this.points)) {
            data["Points"] = [];
            for (let item of this.points)
                data["Points"].push(item ? item.toJSON() : null as any);
        }
        data["Cooldown"] = this.cooldown !== undefined ? this.cooldown : null as any;
        data["Enabled"] = this.enabled !== undefined ? this.enabled : null as any;
        data["ZoneType"] = this.zoneType !== undefined ? this.zoneType : null as any;
        return data;
    }
}

export interface IFenceZoneDto {
    name?: string;
    points?: FencePointDto[];
    cooldown?: number;
    enabled?: boolean;
    zoneType?: string;
}

export class FencePointDto implements IFencePointDto {
    x?: number;
    y?: number;

    constructor(data?: IFencePointDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.x = _data["X"] !== undefined ? _data["X"] : null as any;
            this.y = _data["Y"] !== undefined ? _data["Y"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): FencePointDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FencePointDto>(data, _mappings, FencePointDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["X"] = this.x !== undefined ? this.x : null as any;
        data["Y"] = this.y !== undefined ? this.y : null as any;
        return data;
    }
}

export interface IFencePointDto {
    x?: number;
    y?: number;
}

export class UpdateFenceZonesResponse implements IUpdateFenceZonesResponse {
    message?: string;
    count?: number;

    constructor(data?: IUpdateFenceZonesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
            this.count = _data["count"] !== undefined ? _data["count"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): UpdateFenceZonesResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<UpdateFenceZonesResponse>(data, _mappings, UpdateFenceZonesResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message !== undefined ? this.message : null as any;
        data["count"] = this.count !== undefined ? this.count : null as any;
        return data;
    }
}

export interface IUpdateFenceZonesResponse {
    message?: string;
    count?: number;
}

export class UpdateFenceZonesRequest implements IUpdateFenceZonesRequest {
    device_serial?: string;
    zones?: FenceZoneDto[];

    constructor(data?: IUpdateFenceZonesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.device_serial = _data["device_serial"] !== undefined ? _data["device_serial"] : null as any;
            if (Array.isArray(_data["zones"])) {
                this.zones = [] as any;
                for (let item of _data["zones"])
                    this.zones!.push(FenceZoneDto.fromJS(item, _mappings));
            }
            else {
                this.zones = null as any;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): UpdateFenceZonesRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<UpdateFenceZonesRequest>(data, _mappings, UpdateFenceZonesRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["device_serial"] = this.device_serial !== undefined ? this.device_serial : null as any;
        if (Array.isArray(this.zones)) {
            data["zones"] = [];
            for (let item of this.zones)
                data["zones"].push(item ? item.toJSON() : null as any);
        }
        return data;
    }
}

export interface IUpdateFenceZonesRequest {
    device_serial?: string;
    zones?: FenceZoneDto[];
}

export class ResultOfPagedResponseOfCrowdRecordListResponse implements IResultOfPagedResponseOfCrowdRecordListResponse {
    success?: boolean;
    data?: PagedResponseOfCrowdRecordListResponse | null;
    message?: string | null;
    errors?: string[];
    code?: string | null;
    timestamp?: Date;

    constructor(data?: IResultOfPagedResponseOfCrowdRecordListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : null as any;
            this.data = _data["data"] ? PagedResponseOfCrowdRecordListResponse.fromJS(_data["data"], _mappings) : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            else {
                this.errors = null as any;
            }
            this.code = _data["code"] !== undefined ? _data["code"] : null as any;
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): ResultOfPagedResponseOfCrowdRecordListResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ResultOfPagedResponseOfCrowdRecordListResponse>(data, _mappings, ResultOfPagedResponseOfCrowdRecordListResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : null as any;
        data["data"] = this.data ? this.data.toJSON() : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["code"] = this.code !== undefined ? this.code : null as any;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : null as any;
        return data;
    }
}

export interface IResultOfPagedResponseOfCrowdRecordListResponse {
    success?: boolean;
    data?: PagedResponseOfCrowdRecordListResponse | null;
    message?: string | null;
    errors?: string[];
    code?: string | null;
    timestamp?: Date;
}

export class PagedResponseOfCrowdRecordListResponse implements IPagedResponseOfCrowdRecordListResponse {
    data?: CrowdRecordListResponse[];
    totalCount?: number;
    page?: number;
    size?: number;
    totalPages?: number;
    hasNextPage?: boolean;
    hasPreviousPage?: boolean;
    success?: boolean;
    message?: string | null;

    constructor(data?: IPagedResponseOfCrowdRecordListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CrowdRecordListResponse.fromJS(item, _mappings));
            }
            else {
                this.data = null as any;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : null as any;
            this.page = _data["page"] !== undefined ? _data["page"] : null as any;
            this.size = _data["size"] !== undefined ? _data["size"] : null as any;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : null as any;
            this.hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : null as any;
            this.hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : null as any;
            this.success = _data["success"] !== undefined ? _data["success"] : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): PagedResponseOfCrowdRecordListResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PagedResponseOfCrowdRecordListResponse>(data, _mappings, PagedResponseOfCrowdRecordListResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : null as any);
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : null as any;
        data["page"] = this.page !== undefined ? this.page : null as any;
        data["size"] = this.size !== undefined ? this.size : null as any;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : null as any;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : null as any;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : null as any;
        data["success"] = this.success !== undefined ? this.success : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        return data;
    }
}

export interface IPagedResponseOfCrowdRecordListResponse {
    data?: CrowdRecordListResponse[];
    totalCount?: number;
    page?: number;
    size?: number;
    totalPages?: number;
    hasNextPage?: boolean;
    hasPreviousPage?: boolean;
    success?: boolean;
    message?: string | null;
}

export class CrowdRecordListResponse implements ICrowdRecordListResponse {
    id?: number;
    deviceSerial?: string;
    deviceName?: string;
    stationName?: string;
    area?: number;
    peopleCount?: number;
    density?: number;
    time?: string;
    timestamp?: number;

    constructor(data?: ICrowdRecordListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.deviceSerial = _data["deviceSerial"] !== undefined ? _data["deviceSerial"] : null as any;
            this.deviceName = _data["deviceName"] !== undefined ? _data["deviceName"] : null as any;
            this.stationName = _data["stationName"] !== undefined ? _data["stationName"] : null as any;
            this.area = _data["area"] !== undefined ? _data["area"] : null as any;
            this.peopleCount = _data["peopleCount"] !== undefined ? _data["peopleCount"] : null as any;
            this.density = _data["density"] !== undefined ? _data["density"] : null as any;
            this.time = _data["time"] !== undefined ? _data["time"] : null as any;
            this.timestamp = _data["timestamp"] !== undefined ? _data["timestamp"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): CrowdRecordListResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CrowdRecordListResponse>(data, _mappings, CrowdRecordListResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["deviceSerial"] = this.deviceSerial !== undefined ? this.deviceSerial : null as any;
        data["deviceName"] = this.deviceName !== undefined ? this.deviceName : null as any;
        data["stationName"] = this.stationName !== undefined ? this.stationName : null as any;
        data["area"] = this.area !== undefined ? this.area : null as any;
        data["peopleCount"] = this.peopleCount !== undefined ? this.peopleCount : null as any;
        data["density"] = this.density !== undefined ? this.density : null as any;
        data["time"] = this.time !== undefined ? this.time : null as any;
        data["timestamp"] = this.timestamp !== undefined ? this.timestamp : null as any;
        return data;
    }
}

export interface ICrowdRecordListResponse {
    id?: number;
    deviceSerial?: string;
    deviceName?: string;
    stationName?: string;
    area?: number;
    peopleCount?: number;
    density?: number;
    time?: string;
    timestamp?: number;
}

export class ResultOfInteger implements IResultOfInteger {
    success?: boolean;
    data?: number;
    message?: string | null;
    errors?: string[];
    code?: string | null;
    timestamp?: Date;

    constructor(data?: IResultOfInteger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : null as any;
            this.data = _data["data"] !== undefined ? _data["data"] : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            else {
                this.errors = null as any;
            }
            this.code = _data["code"] !== undefined ? _data["code"] : null as any;
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): ResultOfInteger | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ResultOfInteger>(data, _mappings, ResultOfInteger);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : null as any;
        data["data"] = this.data !== undefined ? this.data : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["code"] = this.code !== undefined ? this.code : null as any;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : null as any;
        return data;
    }
}

export interface IResultOfInteger {
    success?: boolean;
    data?: number;
    message?: string | null;
    errors?: string[];
    code?: string | null;
    timestamp?: Date;
}

export class Result implements IResult {
    success?: boolean;
    message?: string | null;
    errors?: string[];
    code?: string | null;
    timestamp?: Date;

    constructor(data?: IResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            else {
                this.errors = null as any;
            }
            this.code = _data["code"] !== undefined ? _data["code"] : null as any;
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): Result | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Result>(data, _mappings, Result);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["code"] = this.code !== undefined ? this.code : null as any;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : null as any;
        return data;
    }
}

export interface IResult {
    success?: boolean;
    message?: string | null;
    errors?: string[];
    code?: string | null;
    timestamp?: Date;
}

export class ResultOfPagedResponseOfFenceRecordListResponse implements IResultOfPagedResponseOfFenceRecordListResponse {
    success?: boolean;
    data?: PagedResponseOfFenceRecordListResponse | null;
    message?: string | null;
    errors?: string[];
    code?: string | null;
    timestamp?: Date;

    constructor(data?: IResultOfPagedResponseOfFenceRecordListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : null as any;
            this.data = _data["data"] ? PagedResponseOfFenceRecordListResponse.fromJS(_data["data"], _mappings) : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            else {
                this.errors = null as any;
            }
            this.code = _data["code"] !== undefined ? _data["code"] : null as any;
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): ResultOfPagedResponseOfFenceRecordListResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ResultOfPagedResponseOfFenceRecordListResponse>(data, _mappings, ResultOfPagedResponseOfFenceRecordListResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : null as any;
        data["data"] = this.data ? this.data.toJSON() : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["code"] = this.code !== undefined ? this.code : null as any;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : null as any;
        return data;
    }
}

export interface IResultOfPagedResponseOfFenceRecordListResponse {
    success?: boolean;
    data?: PagedResponseOfFenceRecordListResponse | null;
    message?: string | null;
    errors?: string[];
    code?: string | null;
    timestamp?: Date;
}

export class PagedResponseOfFenceRecordListResponse implements IPagedResponseOfFenceRecordListResponse {
    data?: FenceRecordListResponse[];
    totalCount?: number;
    page?: number;
    size?: number;
    totalPages?: number;
    hasNextPage?: boolean;
    hasPreviousPage?: boolean;
    success?: boolean;
    message?: string | null;

    constructor(data?: IPagedResponseOfFenceRecordListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(FenceRecordListResponse.fromJS(item, _mappings));
            }
            else {
                this.data = null as any;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : null as any;
            this.page = _data["page"] !== undefined ? _data["page"] : null as any;
            this.size = _data["size"] !== undefined ? _data["size"] : null as any;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : null as any;
            this.hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : null as any;
            this.hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : null as any;
            this.success = _data["success"] !== undefined ? _data["success"] : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): PagedResponseOfFenceRecordListResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PagedResponseOfFenceRecordListResponse>(data, _mappings, PagedResponseOfFenceRecordListResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : null as any);
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : null as any;
        data["page"] = this.page !== undefined ? this.page : null as any;
        data["size"] = this.size !== undefined ? this.size : null as any;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : null as any;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : null as any;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : null as any;
        data["success"] = this.success !== undefined ? this.success : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        return data;
    }
}

export interface IPagedResponseOfFenceRecordListResponse {
    data?: FenceRecordListResponse[];
    totalCount?: number;
    page?: number;
    size?: number;
    totalPages?: number;
    hasNextPage?: boolean;
    hasPreviousPage?: boolean;
    success?: boolean;
    message?: string | null;
}

export class FenceRecordListResponse implements IFenceRecordListResponse {
    id?: number;
    deviceSerial?: string;
    deviceName?: string;
    stationName?: string;
    event?: string;
    imageUrl?: string | null;
    time?: string;
    timestamp?: number;

    constructor(data?: IFenceRecordListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.deviceSerial = _data["deviceSerial"] !== undefined ? _data["deviceSerial"] : null as any;
            this.deviceName = _data["deviceName"] !== undefined ? _data["deviceName"] : null as any;
            this.stationName = _data["stationName"] !== undefined ? _data["stationName"] : null as any;
            this.event = _data["event"] !== undefined ? _data["event"] : null as any;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : null as any;
            this.time = _data["time"] !== undefined ? _data["time"] : null as any;
            this.timestamp = _data["timestamp"] !== undefined ? _data["timestamp"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): FenceRecordListResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FenceRecordListResponse>(data, _mappings, FenceRecordListResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["deviceSerial"] = this.deviceSerial !== undefined ? this.deviceSerial : null as any;
        data["deviceName"] = this.deviceName !== undefined ? this.deviceName : null as any;
        data["stationName"] = this.stationName !== undefined ? this.stationName : null as any;
        data["event"] = this.event !== undefined ? this.event : null as any;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : null as any;
        data["time"] = this.time !== undefined ? this.time : null as any;
        data["timestamp"] = this.timestamp !== undefined ? this.timestamp : null as any;
        return data;
    }
}

export interface IFenceRecordListResponse {
    id?: number;
    deviceSerial?: string;
    deviceName?: string;
    stationName?: string;
    event?: string;
    imageUrl?: string | null;
    time?: string;
    timestamp?: number;
}

export class ResultOfPagedResponseOfParkingRecordListResponse implements IResultOfPagedResponseOfParkingRecordListResponse {
    success?: boolean;
    data?: PagedResponseOfParkingRecordListResponse | null;
    message?: string | null;
    errors?: string[];
    code?: string | null;
    timestamp?: Date;

    constructor(data?: IResultOfPagedResponseOfParkingRecordListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : null as any;
            this.data = _data["data"] ? PagedResponseOfParkingRecordListResponse.fromJS(_data["data"], _mappings) : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            else {
                this.errors = null as any;
            }
            this.code = _data["code"] !== undefined ? _data["code"] : null as any;
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): ResultOfPagedResponseOfParkingRecordListResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ResultOfPagedResponseOfParkingRecordListResponse>(data, _mappings, ResultOfPagedResponseOfParkingRecordListResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : null as any;
        data["data"] = this.data ? this.data.toJSON() : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["code"] = this.code !== undefined ? this.code : null as any;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : null as any;
        return data;
    }
}

export interface IResultOfPagedResponseOfParkingRecordListResponse {
    success?: boolean;
    data?: PagedResponseOfParkingRecordListResponse | null;
    message?: string | null;
    errors?: string[];
    code?: string | null;
    timestamp?: Date;
}

export class PagedResponseOfParkingRecordListResponse implements IPagedResponseOfParkingRecordListResponse {
    data?: ParkingRecordListResponse[];
    totalCount?: number;
    page?: number;
    size?: number;
    totalPages?: number;
    hasNextPage?: boolean;
    hasPreviousPage?: boolean;
    success?: boolean;
    message?: string | null;

    constructor(data?: IPagedResponseOfParkingRecordListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ParkingRecordListResponse.fromJS(item, _mappings));
            }
            else {
                this.data = null as any;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : null as any;
            this.page = _data["page"] !== undefined ? _data["page"] : null as any;
            this.size = _data["size"] !== undefined ? _data["size"] : null as any;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : null as any;
            this.hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : null as any;
            this.hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : null as any;
            this.success = _data["success"] !== undefined ? _data["success"] : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): PagedResponseOfParkingRecordListResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PagedResponseOfParkingRecordListResponse>(data, _mappings, PagedResponseOfParkingRecordListResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : null as any);
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : null as any;
        data["page"] = this.page !== undefined ? this.page : null as any;
        data["size"] = this.size !== undefined ? this.size : null as any;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : null as any;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : null as any;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : null as any;
        data["success"] = this.success !== undefined ? this.success : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        return data;
    }
}

export interface IPagedResponseOfParkingRecordListResponse {
    data?: ParkingRecordListResponse[];
    totalCount?: number;
    page?: number;
    size?: number;
    totalPages?: number;
    hasNextPage?: boolean;
    hasPreviousPage?: boolean;
    success?: boolean;
    message?: string | null;
}

export class ParkingRecordListResponse implements IParkingRecordListResponse {
    id?: number;
    deviceSerial?: string;
    deviceName?: string;
    stationName?: string;
    totalSpaces?: number;
    parkedNum?: number;
    availableSpaces?: number;
    occupancyRate?: number;
    time?: string;
    timestamp?: number;

    constructor(data?: IParkingRecordListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.deviceSerial = _data["deviceSerial"] !== undefined ? _data["deviceSerial"] : null as any;
            this.deviceName = _data["deviceName"] !== undefined ? _data["deviceName"] : null as any;
            this.stationName = _data["stationName"] !== undefined ? _data["stationName"] : null as any;
            this.totalSpaces = _data["totalSpaces"] !== undefined ? _data["totalSpaces"] : null as any;
            this.parkedNum = _data["parkedNum"] !== undefined ? _data["parkedNum"] : null as any;
            this.availableSpaces = _data["availableSpaces"] !== undefined ? _data["availableSpaces"] : null as any;
            this.occupancyRate = _data["occupancyRate"] !== undefined ? _data["occupancyRate"] : null as any;
            this.time = _data["time"] !== undefined ? _data["time"] : null as any;
            this.timestamp = _data["timestamp"] !== undefined ? _data["timestamp"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): ParkingRecordListResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ParkingRecordListResponse>(data, _mappings, ParkingRecordListResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["deviceSerial"] = this.deviceSerial !== undefined ? this.deviceSerial : null as any;
        data["deviceName"] = this.deviceName !== undefined ? this.deviceName : null as any;
        data["stationName"] = this.stationName !== undefined ? this.stationName : null as any;
        data["totalSpaces"] = this.totalSpaces !== undefined ? this.totalSpaces : null as any;
        data["parkedNum"] = this.parkedNum !== undefined ? this.parkedNum : null as any;
        data["availableSpaces"] = this.availableSpaces !== undefined ? this.availableSpaces : null as any;
        data["occupancyRate"] = this.occupancyRate !== undefined ? this.occupancyRate : null as any;
        data["time"] = this.time !== undefined ? this.time : null as any;
        data["timestamp"] = this.timestamp !== undefined ? this.timestamp : null as any;
        return data;
    }
}

export interface IParkingRecordListResponse {
    id?: number;
    deviceSerial?: string;
    deviceName?: string;
    stationName?: string;
    totalSpaces?: number;
    parkedNum?: number;
    availableSpaces?: number;
    occupancyRate?: number;
    time?: string;
    timestamp?: number;
}

export class ResultOfPagedResponseOfTrafficRecordListResponse implements IResultOfPagedResponseOfTrafficRecordListResponse {
    success?: boolean;
    data?: PagedResponseOfTrafficRecordListResponse | null;
    message?: string | null;
    errors?: string[];
    code?: string | null;
    timestamp?: Date;

    constructor(data?: IResultOfPagedResponseOfTrafficRecordListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : null as any;
            this.data = _data["data"] ? PagedResponseOfTrafficRecordListResponse.fromJS(_data["data"], _mappings) : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            else {
                this.errors = null as any;
            }
            this.code = _data["code"] !== undefined ? _data["code"] : null as any;
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): ResultOfPagedResponseOfTrafficRecordListResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ResultOfPagedResponseOfTrafficRecordListResponse>(data, _mappings, ResultOfPagedResponseOfTrafficRecordListResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : null as any;
        data["data"] = this.data ? this.data.toJSON() : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["code"] = this.code !== undefined ? this.code : null as any;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : null as any;
        return data;
    }
}

export interface IResultOfPagedResponseOfTrafficRecordListResponse {
    success?: boolean;
    data?: PagedResponseOfTrafficRecordListResponse | null;
    message?: string | null;
    errors?: string[];
    code?: string | null;
    timestamp?: Date;
}

export class PagedResponseOfTrafficRecordListResponse implements IPagedResponseOfTrafficRecordListResponse {
    data?: TrafficRecordListResponse[];
    totalCount?: number;
    page?: number;
    size?: number;
    totalPages?: number;
    hasNextPage?: boolean;
    hasPreviousPage?: boolean;
    success?: boolean;
    message?: string | null;

    constructor(data?: IPagedResponseOfTrafficRecordListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(TrafficRecordListResponse.fromJS(item, _mappings));
            }
            else {
                this.data = null as any;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : null as any;
            this.page = _data["page"] !== undefined ? _data["page"] : null as any;
            this.size = _data["size"] !== undefined ? _data["size"] : null as any;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : null as any;
            this.hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : null as any;
            this.hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : null as any;
            this.success = _data["success"] !== undefined ? _data["success"] : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): PagedResponseOfTrafficRecordListResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PagedResponseOfTrafficRecordListResponse>(data, _mappings, PagedResponseOfTrafficRecordListResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : null as any);
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : null as any;
        data["page"] = this.page !== undefined ? this.page : null as any;
        data["size"] = this.size !== undefined ? this.size : null as any;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : null as any;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : null as any;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : null as any;
        data["success"] = this.success !== undefined ? this.success : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        return data;
    }
}

export interface IPagedResponseOfTrafficRecordListResponse {
    data?: TrafficRecordListResponse[];
    totalCount?: number;
    page?: number;
    size?: number;
    totalPages?: number;
    hasNextPage?: boolean;
    hasPreviousPage?: boolean;
    success?: boolean;
    message?: string | null;
}

export class TrafficRecordListResponse implements ITrafficRecordListResponse {
    id?: number;
    deviceSerial?: string;
    deviceName?: string;
    stationName?: string;
    city?: string;
    eTagNumber?: string;
    speedLimit?: number;
    vehicleCount?: number;
    averageSpeed?: number;
    speedStatus?: string;
    time?: string;
    timestamp?: number;

    constructor(data?: ITrafficRecordListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.deviceSerial = _data["deviceSerial"] !== undefined ? _data["deviceSerial"] : null as any;
            this.deviceName = _data["deviceName"] !== undefined ? _data["deviceName"] : null as any;
            this.stationName = _data["stationName"] !== undefined ? _data["stationName"] : null as any;
            this.city = _data["city"] !== undefined ? _data["city"] : null as any;
            this.eTagNumber = _data["eTagNumber"] !== undefined ? _data["eTagNumber"] : null as any;
            this.speedLimit = _data["speedLimit"] !== undefined ? _data["speedLimit"] : null as any;
            this.vehicleCount = _data["vehicleCount"] !== undefined ? _data["vehicleCount"] : null as any;
            this.averageSpeed = _data["averageSpeed"] !== undefined ? _data["averageSpeed"] : null as any;
            this.speedStatus = _data["speedStatus"] !== undefined ? _data["speedStatus"] : null as any;
            this.time = _data["time"] !== undefined ? _data["time"] : null as any;
            this.timestamp = _data["timestamp"] !== undefined ? _data["timestamp"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): TrafficRecordListResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TrafficRecordListResponse>(data, _mappings, TrafficRecordListResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["deviceSerial"] = this.deviceSerial !== undefined ? this.deviceSerial : null as any;
        data["deviceName"] = this.deviceName !== undefined ? this.deviceName : null as any;
        data["stationName"] = this.stationName !== undefined ? this.stationName : null as any;
        data["city"] = this.city !== undefined ? this.city : null as any;
        data["eTagNumber"] = this.eTagNumber !== undefined ? this.eTagNumber : null as any;
        data["speedLimit"] = this.speedLimit !== undefined ? this.speedLimit : null as any;
        data["vehicleCount"] = this.vehicleCount !== undefined ? this.vehicleCount : null as any;
        data["averageSpeed"] = this.averageSpeed !== undefined ? this.averageSpeed : null as any;
        data["speedStatus"] = this.speedStatus !== undefined ? this.speedStatus : null as any;
        data["time"] = this.time !== undefined ? this.time : null as any;
        data["timestamp"] = this.timestamp !== undefined ? this.timestamp : null as any;
        return data;
    }
}

export interface ITrafficRecordListResponse {
    id?: number;
    deviceSerial?: string;
    deviceName?: string;
    stationName?: string;
    city?: string;
    eTagNumber?: string;
    speedLimit?: number;
    vehicleCount?: number;
    averageSpeed?: number;
    speedStatus?: string;
    time?: string;
    timestamp?: number;
}

export class CrowdCapacityHistoryResponse implements ICrowdCapacityHistoryResponse {
    data?: CrowdHistoryData[];
    success?: boolean;
    message?: string | null;

    constructor(data?: ICrowdCapacityHistoryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CrowdHistoryData.fromJS(item, _mappings));
            }
            else {
                this.data = null as any;
            }
            this.success = _data["success"] !== undefined ? _data["success"] : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): CrowdCapacityHistoryResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CrowdCapacityHistoryResponse>(data, _mappings, CrowdCapacityHistoryResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : null as any);
        }
        data["success"] = this.success !== undefined ? this.success : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        return data;
    }
}

export interface ICrowdCapacityHistoryResponse {
    data?: CrowdHistoryData[];
    success?: boolean;
    message?: string | null;
}

export class CrowdHistoryData implements ICrowdHistoryData {
    time?: string;
    timestamp?: number;
    peopleCount?: number;
    area?: number;
    density?: number;
    stationName?: string;
    deviceName?: string;

    constructor(data?: ICrowdHistoryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.time = _data["time"] !== undefined ? _data["time"] : null as any;
            this.timestamp = _data["timestamp"] !== undefined ? _data["timestamp"] : null as any;
            this.peopleCount = _data["peopleCount"] !== undefined ? _data["peopleCount"] : null as any;
            this.area = _data["area"] !== undefined ? _data["area"] : null as any;
            this.density = _data["density"] !== undefined ? _data["density"] : null as any;
            this.stationName = _data["stationName"] !== undefined ? _data["stationName"] : null as any;
            this.deviceName = _data["deviceName"] !== undefined ? _data["deviceName"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): CrowdHistoryData | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CrowdHistoryData>(data, _mappings, CrowdHistoryData);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time !== undefined ? this.time : null as any;
        data["timestamp"] = this.timestamp !== undefined ? this.timestamp : null as any;
        data["peopleCount"] = this.peopleCount !== undefined ? this.peopleCount : null as any;
        data["area"] = this.area !== undefined ? this.area : null as any;
        data["density"] = this.density !== undefined ? this.density : null as any;
        data["stationName"] = this.stationName !== undefined ? this.stationName : null as any;
        data["deviceName"] = this.deviceName !== undefined ? this.deviceName : null as any;
        return data;
    }
}

export interface ICrowdHistoryData {
    time?: string;
    timestamp?: number;
    peopleCount?: number;
    area?: number;
    density?: number;
    stationName?: string;
    deviceName?: string;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | null;
    title?: string | null;
    status?: number | null;
    detail?: string | null;
    instance?: string | null;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"] !== undefined ? _data["type"] : null as any;
            this.title = _data["title"] !== undefined ? _data["title"] : null as any;
            this.status = _data["status"] !== undefined ? _data["status"] : null as any;
            this.detail = _data["detail"] !== undefined ? _data["detail"] : null as any;
            this.instance = _data["instance"] !== undefined ? _data["instance"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): ProblemDetails | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ProblemDetails>(data, _mappings, ProblemDetails);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type !== undefined ? this.type : null as any;
        data["title"] = this.title !== undefined ? this.title : null as any;
        data["status"] = this.status !== undefined ? this.status : null as any;
        data["detail"] = this.detail !== undefined ? this.detail : null as any;
        data["instance"] = this.instance !== undefined ? this.instance : null as any;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | null;
    title?: string | null;
    status?: number | null;
    detail?: string | null;
    instance?: string | null;

    [key: string]: any;
}

export class CrowdCapacityRateResponse implements ICrowdCapacityRateResponse {
    data?: CrowdRateData[];
    success?: boolean;
    message?: string | null;

    constructor(data?: ICrowdCapacityRateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CrowdRateData.fromJS(item, _mappings));
            }
            else {
                this.data = null as any;
            }
            this.success = _data["success"] !== undefined ? _data["success"] : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): CrowdCapacityRateResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CrowdCapacityRateResponse>(data, _mappings, CrowdCapacityRateResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : null as any);
        }
        data["success"] = this.success !== undefined ? this.success : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        return data;
    }
}

export interface ICrowdCapacityRateResponse {
    data?: CrowdRateData[];
    success?: boolean;
    message?: string | null;
}

export class CrowdRateData implements ICrowdRateData {
    deviceId?: number;
    stationId?: number;
    stationName?: string;
    deviceName?: string;
    averageDensity?: number;
    averagePeopleCount?: number;
    totalRecords?: number;
    latestTime?: string;
    status?: string;
    rate?: number;

    constructor(data?: ICrowdRateData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"] !== undefined ? _data["deviceId"] : null as any;
            this.stationId = _data["stationId"] !== undefined ? _data["stationId"] : null as any;
            this.stationName = _data["stationName"] !== undefined ? _data["stationName"] : null as any;
            this.deviceName = _data["deviceName"] !== undefined ? _data["deviceName"] : null as any;
            this.averageDensity = _data["averageDensity"] !== undefined ? _data["averageDensity"] : null as any;
            this.averagePeopleCount = _data["averagePeopleCount"] !== undefined ? _data["averagePeopleCount"] : null as any;
            this.totalRecords = _data["totalRecords"] !== undefined ? _data["totalRecords"] : null as any;
            this.latestTime = _data["latestTime"] !== undefined ? _data["latestTime"] : null as any;
            this.status = _data["status"] !== undefined ? _data["status"] : null as any;
            this.rate = _data["rate"] !== undefined ? _data["rate"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): CrowdRateData | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CrowdRateData>(data, _mappings, CrowdRateData);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId !== undefined ? this.deviceId : null as any;
        data["stationId"] = this.stationId !== undefined ? this.stationId : null as any;
        data["stationName"] = this.stationName !== undefined ? this.stationName : null as any;
        data["deviceName"] = this.deviceName !== undefined ? this.deviceName : null as any;
        data["averageDensity"] = this.averageDensity !== undefined ? this.averageDensity : null as any;
        data["averagePeopleCount"] = this.averagePeopleCount !== undefined ? this.averagePeopleCount : null as any;
        data["totalRecords"] = this.totalRecords !== undefined ? this.totalRecords : null as any;
        data["latestTime"] = this.latestTime !== undefined ? this.latestTime : null as any;
        data["status"] = this.status !== undefined ? this.status : null as any;
        data["rate"] = this.rate !== undefined ? this.rate : null as any;
        return data;
    }
}

export interface ICrowdRateData {
    deviceId?: number;
    stationId?: number;
    stationName?: string;
    deviceName?: string;
    averageDensity?: number;
    averagePeopleCount?: number;
    totalRecords?: number;
    latestTime?: string;
    status?: string;
    rate?: number;
}

export class FenceRecordHistoryResponse implements IFenceRecordHistoryResponse {
    data?: FenceHistoryData[];
    success?: boolean;
    message?: string | null;

    constructor(data?: IFenceRecordHistoryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(FenceHistoryData.fromJS(item, _mappings));
            }
            else {
                this.data = null as any;
            }
            this.success = _data["success"] !== undefined ? _data["success"] : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): FenceRecordHistoryResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FenceRecordHistoryResponse>(data, _mappings, FenceRecordHistoryResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : null as any);
        }
        data["success"] = this.success !== undefined ? this.success : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        return data;
    }
}

export interface IFenceRecordHistoryResponse {
    data?: FenceHistoryData[];
    success?: boolean;
    message?: string | null;
}

export class FenceHistoryData implements IFenceHistoryData {
    time?: string;
    timestamp?: number;
    eventType?: number;
    event?: string;
    stationName?: string;
    deviceName?: string;

    constructor(data?: IFenceHistoryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.time = _data["time"] !== undefined ? _data["time"] : null as any;
            this.timestamp = _data["timestamp"] !== undefined ? _data["timestamp"] : null as any;
            this.eventType = _data["eventType"] !== undefined ? _data["eventType"] : null as any;
            this.event = _data["event"] !== undefined ? _data["event"] : null as any;
            this.stationName = _data["stationName"] !== undefined ? _data["stationName"] : null as any;
            this.deviceName = _data["deviceName"] !== undefined ? _data["deviceName"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): FenceHistoryData | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FenceHistoryData>(data, _mappings, FenceHistoryData);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time !== undefined ? this.time : null as any;
        data["timestamp"] = this.timestamp !== undefined ? this.timestamp : null as any;
        data["eventType"] = this.eventType !== undefined ? this.eventType : null as any;
        data["event"] = this.event !== undefined ? this.event : null as any;
        data["stationName"] = this.stationName !== undefined ? this.stationName : null as any;
        data["deviceName"] = this.deviceName !== undefined ? this.deviceName : null as any;
        return data;
    }
}

export interface IFenceHistoryData {
    time?: string;
    timestamp?: number;
    eventType?: number;
    event?: string;
    stationName?: string;
    deviceName?: string;
}

export class FenceRecentRecordDetailResponse implements IFenceRecentRecordDetailResponse {
    data?: FenceRecentRecordDetail[];
    success?: boolean;
    message?: string | null;

    constructor(data?: IFenceRecentRecordDetailResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(FenceRecentRecordDetail.fromJS(item, _mappings));
            }
            else {
                this.data = null as any;
            }
            this.success = _data["success"] !== undefined ? _data["success"] : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): FenceRecentRecordDetailResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FenceRecentRecordDetailResponse>(data, _mappings, FenceRecentRecordDetailResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : null as any);
        }
        data["success"] = this.success !== undefined ? this.success : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        return data;
    }
}

export interface IFenceRecentRecordDetailResponse {
    data?: FenceRecentRecordDetail[];
    success?: boolean;
    message?: string | null;
}

export class FenceRecentRecordDetail implements IFenceRecentRecordDetail {
    id?: number;
    stationId?: number;
    deviceName?: string;
    station?: string;
    eventType?: number;
    event?: string;
    title?: string;
    imageUrl?: string;
    time?: string;
    timestamp?: number;

    constructor(data?: IFenceRecentRecordDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.stationId = _data["stationId"] !== undefined ? _data["stationId"] : null as any;
            this.deviceName = _data["deviceName"] !== undefined ? _data["deviceName"] : null as any;
            this.station = _data["station"] !== undefined ? _data["station"] : null as any;
            this.eventType = _data["eventType"] !== undefined ? _data["eventType"] : null as any;
            this.event = _data["event"] !== undefined ? _data["event"] : null as any;
            this.title = _data["title"] !== undefined ? _data["title"] : null as any;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : null as any;
            this.time = _data["time"] !== undefined ? _data["time"] : null as any;
            this.timestamp = _data["timestamp"] !== undefined ? _data["timestamp"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): FenceRecentRecordDetail | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FenceRecentRecordDetail>(data, _mappings, FenceRecentRecordDetail);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["stationId"] = this.stationId !== undefined ? this.stationId : null as any;
        data["deviceName"] = this.deviceName !== undefined ? this.deviceName : null as any;
        data["station"] = this.station !== undefined ? this.station : null as any;
        data["eventType"] = this.eventType !== undefined ? this.eventType : null as any;
        data["event"] = this.event !== undefined ? this.event : null as any;
        data["title"] = this.title !== undefined ? this.title : null as any;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : null as any;
        data["time"] = this.time !== undefined ? this.time : null as any;
        data["timestamp"] = this.timestamp !== undefined ? this.timestamp : null as any;
        return data;
    }
}

export interface IFenceRecentRecordDetail {
    id?: number;
    stationId?: number;
    deviceName?: string;
    station?: string;
    eventType?: number;
    event?: string;
    title?: string;
    imageUrl?: string;
    time?: string;
    timestamp?: number;
}

export class FenceLatestRecordResponse implements IFenceLatestRecordResponse {
    data?: FenceLatestData[];
    success?: boolean;
    message?: string | null;

    constructor(data?: IFenceLatestRecordResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(FenceLatestData.fromJS(item, _mappings));
            }
            else {
                this.data = null as any;
            }
            this.success = _data["success"] !== undefined ? _data["success"] : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): FenceLatestRecordResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FenceLatestRecordResponse>(data, _mappings, FenceLatestRecordResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : null as any);
        }
        data["success"] = this.success !== undefined ? this.success : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        return data;
    }
}

export interface IFenceLatestRecordResponse {
    data?: FenceLatestData[];
    success?: boolean;
    message?: string | null;
}

export class FenceLatestData implements IFenceLatestData {
    id?: number;
    stationId?: number;
    stationName?: string;
    deviceName?: string;
    eventType?: number;
    event?: string;
    imageUrl?: string;
    time?: string;
    timestamp?: number;

    constructor(data?: IFenceLatestData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.stationId = _data["stationId"] !== undefined ? _data["stationId"] : null as any;
            this.stationName = _data["stationName"] !== undefined ? _data["stationName"] : null as any;
            this.deviceName = _data["deviceName"] !== undefined ? _data["deviceName"] : null as any;
            this.eventType = _data["eventType"] !== undefined ? _data["eventType"] : null as any;
            this.event = _data["event"] !== undefined ? _data["event"] : null as any;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : null as any;
            this.time = _data["time"] !== undefined ? _data["time"] : null as any;
            this.timestamp = _data["timestamp"] !== undefined ? _data["timestamp"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): FenceLatestData | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FenceLatestData>(data, _mappings, FenceLatestData);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["stationId"] = this.stationId !== undefined ? this.stationId : null as any;
        data["stationName"] = this.stationName !== undefined ? this.stationName : null as any;
        data["deviceName"] = this.deviceName !== undefined ? this.deviceName : null as any;
        data["eventType"] = this.eventType !== undefined ? this.eventType : null as any;
        data["event"] = this.event !== undefined ? this.event : null as any;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : null as any;
        data["time"] = this.time !== undefined ? this.time : null as any;
        data["timestamp"] = this.timestamp !== undefined ? this.timestamp : null as any;
        return data;
    }
}

export interface IFenceLatestData {
    id?: number;
    stationId?: number;
    stationName?: string;
    deviceName?: string;
    eventType?: number;
    event?: string;
    imageUrl?: string;
    time?: string;
    timestamp?: number;
}

export class HighResolutionOverviewResponse implements IHighResolutionOverviewResponse {
    data?: HighResolutionData[];
    success?: boolean;
    message?: string | null;

    constructor(data?: IHighResolutionOverviewResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(HighResolutionData.fromJS(item, _mappings));
            }
            else {
                this.data = null as any;
            }
            this.success = _data["success"] !== undefined ? _data["success"] : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): HighResolutionOverviewResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<HighResolutionOverviewResponse>(data, _mappings, HighResolutionOverviewResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : null as any);
        }
        data["success"] = this.success !== undefined ? this.success : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        return data;
    }
}

export interface IHighResolutionOverviewResponse {
    data?: HighResolutionData[];
    success?: boolean;
    message?: string | null;
}

export class HighResolutionData implements IHighResolutionData {
    stationName?: string;
    deviceName?: string;
    videoUrl?: string;
    status?: string;
    latestOnlineTime?: string;
    lat?: number;
    lng?: number;

    constructor(data?: IHighResolutionData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.stationName = _data["stationName"] !== undefined ? _data["stationName"] : null as any;
            this.deviceName = _data["deviceName"] !== undefined ? _data["deviceName"] : null as any;
            this.videoUrl = _data["videoUrl"] !== undefined ? _data["videoUrl"] : null as any;
            this.status = _data["status"] !== undefined ? _data["status"] : null as any;
            this.latestOnlineTime = _data["latestOnlineTime"] !== undefined ? _data["latestOnlineTime"] : null as any;
            this.lat = _data["lat"] !== undefined ? _data["lat"] : null as any;
            this.lng = _data["lng"] !== undefined ? _data["lng"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): HighResolutionData | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<HighResolutionData>(data, _mappings, HighResolutionData);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stationName"] = this.stationName !== undefined ? this.stationName : null as any;
        data["deviceName"] = this.deviceName !== undefined ? this.deviceName : null as any;
        data["videoUrl"] = this.videoUrl !== undefined ? this.videoUrl : null as any;
        data["status"] = this.status !== undefined ? this.status : null as any;
        data["latestOnlineTime"] = this.latestOnlineTime !== undefined ? this.latestOnlineTime : null as any;
        data["lat"] = this.lat !== undefined ? this.lat : null as any;
        data["lng"] = this.lng !== undefined ? this.lng : null as any;
        return data;
    }
}

export interface IHighResolutionData {
    stationName?: string;
    deviceName?: string;
    videoUrl?: string;
    status?: string;
    latestOnlineTime?: string;
    lat?: number;
    lng?: number;
}

export class ParkingConversionHistoryResponse implements IParkingConversionHistoryResponse {
    data?: ParkingHistoryData[];
    success?: boolean;
    message?: string | null;

    constructor(data?: IParkingConversionHistoryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ParkingHistoryData.fromJS(item, _mappings));
            }
            else {
                this.data = null as any;
            }
            this.success = _data["success"] !== undefined ? _data["success"] : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): ParkingConversionHistoryResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ParkingConversionHistoryResponse>(data, _mappings, ParkingConversionHistoryResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : null as any);
        }
        data["success"] = this.success !== undefined ? this.success : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        return data;
    }
}

export interface IParkingConversionHistoryResponse {
    data?: ParkingHistoryData[];
    success?: boolean;
    message?: string | null;
}

export class ParkingHistoryData implements IParkingHistoryData {
    time?: string;
    timestamp?: number;
    totalSpaces?: number;
    parkedNum?: number;
    availableSpaces?: number;
    occupancyRate?: number;
    stationName?: string;
    deviceName?: string;

    constructor(data?: IParkingHistoryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.time = _data["time"] !== undefined ? _data["time"] : null as any;
            this.timestamp = _data["timestamp"] !== undefined ? _data["timestamp"] : null as any;
            this.totalSpaces = _data["totalSpaces"] !== undefined ? _data["totalSpaces"] : null as any;
            this.parkedNum = _data["parkedNum"] !== undefined ? _data["parkedNum"] : null as any;
            this.availableSpaces = _data["availableSpaces"] !== undefined ? _data["availableSpaces"] : null as any;
            this.occupancyRate = _data["occupancyRate"] !== undefined ? _data["occupancyRate"] : null as any;
            this.stationName = _data["stationName"] !== undefined ? _data["stationName"] : null as any;
            this.deviceName = _data["deviceName"] !== undefined ? _data["deviceName"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): ParkingHistoryData | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ParkingHistoryData>(data, _mappings, ParkingHistoryData);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time !== undefined ? this.time : null as any;
        data["timestamp"] = this.timestamp !== undefined ? this.timestamp : null as any;
        data["totalSpaces"] = this.totalSpaces !== undefined ? this.totalSpaces : null as any;
        data["parkedNum"] = this.parkedNum !== undefined ? this.parkedNum : null as any;
        data["availableSpaces"] = this.availableSpaces !== undefined ? this.availableSpaces : null as any;
        data["occupancyRate"] = this.occupancyRate !== undefined ? this.occupancyRate : null as any;
        data["stationName"] = this.stationName !== undefined ? this.stationName : null as any;
        data["deviceName"] = this.deviceName !== undefined ? this.deviceName : null as any;
        return data;
    }
}

export interface IParkingHistoryData {
    time?: string;
    timestamp?: number;
    totalSpaces?: number;
    parkedNum?: number;
    availableSpaces?: number;
    occupancyRate?: number;
    stationName?: string;
    deviceName?: string;
}

export class ParkingRateResponse implements IParkingRateResponse {
    data?: ParkingRateData[];
    success?: boolean;
    message?: string | null;

    constructor(data?: IParkingRateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ParkingRateData.fromJS(item, _mappings));
            }
            else {
                this.data = null as any;
            }
            this.success = _data["success"] !== undefined ? _data["success"] : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): ParkingRateResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ParkingRateResponse>(data, _mappings, ParkingRateResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : null as any);
        }
        data["success"] = this.success !== undefined ? this.success : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        return data;
    }
}

export interface IParkingRateResponse {
    data?: ParkingRateData[];
    success?: boolean;
    message?: string | null;
}

export class ParkingRateData implements IParkingRateData {
    deviceId?: number;
    stationId?: number;
    stationName?: string;
    deviceName?: string;
    averageOccupancyRate?: number;
    totalRecords?: number;
    latestTime?: string;
    status?: string;
    rate?: number;

    constructor(data?: IParkingRateData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"] !== undefined ? _data["deviceId"] : null as any;
            this.stationId = _data["stationId"] !== undefined ? _data["stationId"] : null as any;
            this.stationName = _data["stationName"] !== undefined ? _data["stationName"] : null as any;
            this.deviceName = _data["deviceName"] !== undefined ? _data["deviceName"] : null as any;
            this.averageOccupancyRate = _data["averageOccupancyRate"] !== undefined ? _data["averageOccupancyRate"] : null as any;
            this.totalRecords = _data["totalRecords"] !== undefined ? _data["totalRecords"] : null as any;
            this.latestTime = _data["latestTime"] !== undefined ? _data["latestTime"] : null as any;
            this.status = _data["status"] !== undefined ? _data["status"] : null as any;
            this.rate = _data["rate"] !== undefined ? _data["rate"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): ParkingRateData | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ParkingRateData>(data, _mappings, ParkingRateData);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId !== undefined ? this.deviceId : null as any;
        data["stationId"] = this.stationId !== undefined ? this.stationId : null as any;
        data["stationName"] = this.stationName !== undefined ? this.stationName : null as any;
        data["deviceName"] = this.deviceName !== undefined ? this.deviceName : null as any;
        data["averageOccupancyRate"] = this.averageOccupancyRate !== undefined ? this.averageOccupancyRate : null as any;
        data["totalRecords"] = this.totalRecords !== undefined ? this.totalRecords : null as any;
        data["latestTime"] = this.latestTime !== undefined ? this.latestTime : null as any;
        data["status"] = this.status !== undefined ? this.status : null as any;
        data["rate"] = this.rate !== undefined ? this.rate : null as any;
        return data;
    }
}

export interface IParkingRateData {
    deviceId?: number;
    stationId?: number;
    stationName?: string;
    deviceName?: string;
    averageOccupancyRate?: number;
    totalRecords?: number;
    latestTime?: string;
    status?: string;
    rate?: number;
}

export class TrafficRoadConditionHistoryResponse implements ITrafficRoadConditionHistoryResponse {
    data?: TrafficHistoryData[];
    success?: boolean;
    message?: string | null;

    constructor(data?: ITrafficRoadConditionHistoryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(TrafficHistoryData.fromJS(item, _mappings));
            }
            else {
                this.data = null as any;
            }
            this.success = _data["success"] !== undefined ? _data["success"] : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): TrafficRoadConditionHistoryResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TrafficRoadConditionHistoryResponse>(data, _mappings, TrafficRoadConditionHistoryResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : null as any);
        }
        data["success"] = this.success !== undefined ? this.success : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        return data;
    }
}

export interface ITrafficRoadConditionHistoryResponse {
    data?: TrafficHistoryData[];
    success?: boolean;
    message?: string | null;
}

export class TrafficHistoryData implements ITrafficHistoryData {
    time?: string;
    timestamp?: number;
    vehicleCount?: number;
    averageSpeed?: number;
    speedStatus?: string;
    stationName?: string;
    deviceName?: string;

    constructor(data?: ITrafficHistoryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.time = _data["time"] !== undefined ? _data["time"] : null as any;
            this.timestamp = _data["timestamp"] !== undefined ? _data["timestamp"] : null as any;
            this.vehicleCount = _data["vehicleCount"] !== undefined ? _data["vehicleCount"] : null as any;
            this.averageSpeed = _data["averageSpeed"] !== undefined ? _data["averageSpeed"] : null as any;
            this.speedStatus = _data["speedStatus"] !== undefined ? _data["speedStatus"] : null as any;
            this.stationName = _data["stationName"] !== undefined ? _data["stationName"] : null as any;
            this.deviceName = _data["deviceName"] !== undefined ? _data["deviceName"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): TrafficHistoryData | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TrafficHistoryData>(data, _mappings, TrafficHistoryData);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time !== undefined ? this.time : null as any;
        data["timestamp"] = this.timestamp !== undefined ? this.timestamp : null as any;
        data["vehicleCount"] = this.vehicleCount !== undefined ? this.vehicleCount : null as any;
        data["averageSpeed"] = this.averageSpeed !== undefined ? this.averageSpeed : null as any;
        data["speedStatus"] = this.speedStatus !== undefined ? this.speedStatus : null as any;
        data["stationName"] = this.stationName !== undefined ? this.stationName : null as any;
        data["deviceName"] = this.deviceName !== undefined ? this.deviceName : null as any;
        return data;
    }
}

export interface ITrafficHistoryData {
    time?: string;
    timestamp?: number;
    vehicleCount?: number;
    averageSpeed?: number;
    speedStatus?: string;
    stationName?: string;
    deviceName?: string;
}

export class TrafficRoadConditionResponse implements ITrafficRoadConditionResponse {
    data?: TrafficConditionData[];
    success?: boolean;
    message?: string | null;

    constructor(data?: ITrafficRoadConditionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(TrafficConditionData.fromJS(item, _mappings));
            }
            else {
                this.data = null as any;
            }
            this.success = _data["success"] !== undefined ? _data["success"] : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): TrafficRoadConditionResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TrafficRoadConditionResponse>(data, _mappings, TrafficRoadConditionResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : null as any);
        }
        data["success"] = this.success !== undefined ? this.success : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        return data;
    }
}

export interface ITrafficRoadConditionResponse {
    data?: TrafficConditionData[];
    success?: boolean;
    message?: string | null;
}

export class TrafficConditionData implements ITrafficConditionData {
    deviceId?: number;
    stationId?: number;
    stationName?: string;
    deviceName?: string;
    averageSpeed?: number;
    averageVehicleCount?: number;
    speedLimit?: number;
    speedStatus?: string;
    totalRecords?: number;
    latestTime?: string;
    status?: string;
    rate?: number;

    constructor(data?: ITrafficConditionData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"] !== undefined ? _data["deviceId"] : null as any;
            this.stationId = _data["stationId"] !== undefined ? _data["stationId"] : null as any;
            this.stationName = _data["stationName"] !== undefined ? _data["stationName"] : null as any;
            this.deviceName = _data["deviceName"] !== undefined ? _data["deviceName"] : null as any;
            this.averageSpeed = _data["averageSpeed"] !== undefined ? _data["averageSpeed"] : null as any;
            this.averageVehicleCount = _data["averageVehicleCount"] !== undefined ? _data["averageVehicleCount"] : null as any;
            this.speedLimit = _data["speedLimit"] !== undefined ? _data["speedLimit"] : null as any;
            this.speedStatus = _data["speedStatus"] !== undefined ? _data["speedStatus"] : null as any;
            this.totalRecords = _data["totalRecords"] !== undefined ? _data["totalRecords"] : null as any;
            this.latestTime = _data["latestTime"] !== undefined ? _data["latestTime"] : null as any;
            this.status = _data["status"] !== undefined ? _data["status"] : null as any;
            this.rate = _data["rate"] !== undefined ? _data["rate"] : null as any;
        }
    }

    static fromJS(data: any, _mappings?: any): TrafficConditionData | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TrafficConditionData>(data, _mappings, TrafficConditionData);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId !== undefined ? this.deviceId : null as any;
        data["stationId"] = this.stationId !== undefined ? this.stationId : null as any;
        data["stationName"] = this.stationName !== undefined ? this.stationName : null as any;
        data["deviceName"] = this.deviceName !== undefined ? this.deviceName : null as any;
        data["averageSpeed"] = this.averageSpeed !== undefined ? this.averageSpeed : null as any;
        data["averageVehicleCount"] = this.averageVehicleCount !== undefined ? this.averageVehicleCount : null as any;
        data["speedLimit"] = this.speedLimit !== undefined ? this.speedLimit : null as any;
        data["speedStatus"] = this.speedStatus !== undefined ? this.speedStatus : null as any;
        data["totalRecords"] = this.totalRecords !== undefined ? this.totalRecords : null as any;
        data["latestTime"] = this.latestTime !== undefined ? this.latestTime : null as any;
        data["status"] = this.status !== undefined ? this.status : null as any;
        data["rate"] = this.rate !== undefined ? this.rate : null as any;
        return data;
    }
}

export interface ITrafficConditionData {
    deviceId?: number;
    stationId?: number;
    stationName?: string;
    deviceName?: string;
    averageSpeed?: number;
    averageVehicleCount?: number;
    speedLimit?: number;
    speedStatus?: string;
    totalRecords?: number;
    latestTime?: string;
    status?: string;
    rate?: number;
}

function jsonParse(json: any, reviver?: any) {
    json = JSON.parse(json, reviver);

    var byid: any = {};
    var refs: any = [];
    json = (function recurse(obj: any, prop?: any, parent?: any) {
        if (typeof obj !== 'object' || !obj)
            return obj;
        
        if ("$ref" in obj) {
            let ref = obj.$ref;
            if (ref in byid)
                return byid[ref];
            refs.push([parent, prop, ref]);
            return undefined;
        } else if ("$id" in obj) {
            let id = obj.$id;
            delete obj.$id;
            if ("$values" in obj)
                obj = obj.$values;
            byid[id] = obj;
        }
        
        if (Array.isArray(obj)) {
            obj = obj.map((v, i) => recurse(v, i, obj));
        } else {
            for (var p in obj) {
                if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')
                    obj[p] = recurse(obj[p], p, obj);
            }
        }

        return obj;
    })(json);

    for (let i = 0; i < refs.length; i++) {
        const ref = refs[i];
        ref[0][ref[1]] = byid[ref[2]];
    }

    return json;
}

function createInstance<T>(data: any, mappings: any, type: any): T | null {
  if (!mappings)
    mappings = [];
  if (!data)
    return null;

  const mappingIndexName = "__mappingIndex";
  if (data[mappingIndexName])
    return <T>mappings[data[mappingIndexName]].target;

  data[mappingIndexName] = mappings.length;

  let result: any = new type();
  mappings.push({ source: data, target: result });
  result.init(data, mappings);
  return result;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    throw new ApiException(message, status, response, headers, result);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}